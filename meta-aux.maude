--- file: meta-aux.maude
--- reqs: prelude, prelude-aux
--- desc: This file extends the meta-level
---       with many additional operations

view Term     from TRIV to META-MODULE is sort Elt to Term     . endv
view TermList from TRIV to META-MODULE is sort Elt to TermList . endv

fmod QIDSET-REFINEMENT is
  pr META-MODULE .
  ---
  var V : Variable .
  var VS : VariableSet .
  var QS1 QS2 : QidSet .
  ---
  sort VariableSet   ConstantSet   TermQidSet    .
  sort NeVariableSet NeConstantSet NeTermQidSet  .
  ---
  subsort Variable < NeVariableSet < VariableSet .
  subsort Constant < NeConstantSet < ConstantSet .
  subsort TermQid  < NeTermQidSet  < TermQidSet  .
  ---
  subsort EmptyTypeSet < ConstantSet VariableSet     .
  subsort VariableSet   ConstantSet   < TermQidSet   .
  subsort NeVariableSet NeConstantSet < NeTermQidSet .
  ---
  subsort TermQidSet   < QidSet   .
  subsort NeTermQidSet < NeQidSet .
  ---
  op _;_ : TermQidSet TermQidSet     -> TermQidSet    [ctor ditto] .
  op _;_ : NeTermQidSet TermQidSet   -> NeTermQidSet  [ctor ditto] .
  op _;_ : ConstantSet ConstantSet   -> ConstantSet   [ctor ditto] .
  op _;_ : NeConstantSet ConstantSet -> NeConstantSet [ctor ditto] .
  op _;_ : VariableSet VariableSet   -> VariableSet   [ctor ditto] .
  op _;_ : NeVariableSet VariableSet -> NeVariableSet [ctor ditto] .

  op pickAny : QidSet -> [Qid] .
  op pickAny : NeQidSet -> Qid .
  eq pickAny(Q:Qid ; QS:QidSet) = Q:Qid .

  op TermList : TermQid -> TermQid .
  op TermList : TermQidSet -> TermList .
  eq TermList(TQ:TermQid ; TQS:TermQidSet) = TQ:TermQid,TermList(TQS:TermQidSet) .
  eq TermList(none) = empty .

  --- FIXME: Input VariableSet must be a proper set (no redundancies)
  ----       for this to work correctly --- ideally should be checked
  op overlappingVarNames : VariableSet -> QidSet .
  op overlappingVarNames : VariableSet QidSet QidSet -> QidSet .
  -------------------------------------------------------------
  eq overlappingVarNames(VS) = overlappingVarNames(VS,none,none) .
  eq overlappingVarNames(V ; VS,QS1,QS2) =
    if getName(V) in QS2
      then overlappingVarNames(VS,QS1 ; getName(V),QS2             )
      else overlappingVarNames(VS,QS1,             QS2 ; getName(V))
    fi .
  eq overlappingVarNames(none,  QS1,QS2) = QS1 .
endfm

--- ### New
fmod TERM-EXTRA is
  pr META-LEVEL .
  pr CONVERSION .
  pr QIDSET-REFINEMENT .

  var TQ : TermQid . var Q : Qid . var QS QS' QS'' : QidSet . var V : Variable .
  var T T' : Term . var NTL : NeTermList . var C : Constant . var TS : TypeSet .
  var M : Module . var TL : TermList . var X Y : Type . var YL : TypeList .
  var N : Nat . var VS : VariableSet . var Str : String .

  --- OUT: The set of variables in a term
  op vars : TermList -> VariableSet .
  eq vars(V) = V .
  eq vars(C) = none .
  eq vars(Q[NTL]) = vars(NTL) .
  eq vars(empty) = none .
  eq vars((T, TL)) = vars(T) ; vars(TL) .

  --- OUT: true iff the QidSet is a TermQid set and all names are unique
  op uniqueNames : QidSet ~> Bool .
  op uniqueNames : QidSet QidSet ~> Bool .
  eq uniqueNames(QS') = uniqueNames(none,QS') .
  eq uniqueNames(QS,Q ; QS') = (not getName(Q) in QS) and-then uniqueNames(QS ; getName(Q),QS') .
  eq uniqueNames(QS,none) = true .

  --- PRE: Each Qid in QidSet is a TermQid
  --- OUT: QidSet composed of the name/sort of each TermQid
  op getName : QidSet -> [QidSet] .
  eq getName(TQ ; Q ; QS) = getName(TQ) ; getName(Q ; QS) .
  eq getName(none) = none .

  op getType : QidSet -> [QidSet] .
  eq getType(TQ ; Q ; QS) = getType(TQ) ; getType(Q ; QS) .
  eq getType(none) = none .

  --- PRE: Each Qid in QidSet is a TermQid
  --- OUT: Set of names (obtained by getName) which are not unique
  op repeatedNames : QidSet -> QidSet .
  eq repeatedNames(QS) = $repeatedNames(QS,none,none) .

  op $repeatedNames : QidSet QidSet QidSet -> QidSet .
  eq $repeatedNames(TQ ; QS,QS',QS'') =
    if getName(TQ) in QS'
      then $repeatedNames(QS,QS',QS'' ; getName(TQ))
      else $repeatedNames(QS,QS' ; getName(TQ),QS'')
    fi .
  eq $repeatedNames(none,QS',QS'') = QS'' .

  --- PRE: Each Qid in QidSet is a TermQid
  --- OUT: QidSet composed of only those TermQids who Type is in TypeSet
  op filterByType : QidSet TypeSet -> [QidSet] .
  eq filterByType(TQ ; QS,TS) =
    if getType(TQ) in TS then TQ else none fi ; filterByType(QS,TS) .
  eq filterByType(none,TS)    = none .

  --- PRE: Each Qid in QidSet is a Variable
  --- OUT: A TermList where each Variable occurs in an undefined order
  op varsToTermList : VariableSet -> [TermList] .
  eq varsToTermList(V ; VS) = V,varsToTermList(VS) .
  eq varsToTermList(none)   = empty .

  --- PRE: None
  --- OUT: The list of subterms from this term
  op subterms : Term -> TermList .
  eq subterms(Q[NTL]) = NTL .
  eq subterms(C) = empty .
  eq subterms(V) = empty .

  --- OUT: the head Qid of the term
  op head : Term -> Qid .
  eq head(Q[NTL]) = Q .
  eq head(TQ) = TQ .

  --- OUT: self-explanatory
  op termSize : TermList -> Nat .
  eq termSize(TQ)     = 1 .
  eq termSize(Q[NTL]) = 1 + termSize(NTL) .
  eq termSize((T,TL)) = termSize(T) + termSize(TL) .
  eq termSize(empty)  = 0 .

  --- OUT: true iff TermList has no repeated variables
  op linear : TermList -> Bool .
  op linear : TermList VariableSet -> Bool .
  eq linear(TL)             = linear(TL,none) .
  eq linear((Q[NTL],TL),VS) = linear((NTL,TL),VS) .
  eq linear((C,TL),     VS) = linear(TL,      VS) .
  eq linear((V,TL),     VS) = (not V in VS) and-then linear(TL,V ; VS) .
  eq linear(empty,      VS) = true .

  --- PRE: the module is sort-decreasing
  --- OUT: true iff one of the terms is provably not equal to other
  ---      to the other because either: one is a ground constructor
  ---      and its least sort is greater than the least sort of the
  ---      other term; guaranteeing the two terms are not equal
  --- NB:  The two terms MUST have distinct sorts to infer that are
  ---      not equal; we need sort-decreasingness to tell us that
  ---      one term is in normal form and the other can only decrease
  ---      so that it must be different
  op groundLeastSortGreater : Module Term Term ~> Bool .
  eq groundLeastSortGreater(M,T,T') =
    groundLeastSortGreater(M,
      T, completeName(M,leastSort(M,T )),
      T',completeName(M,leastSort(M,T'))) .

  op groundLeastSortGreater : Module Term Type Term Type ~> Bool .
  eq groundLeastSortGreater(M,T,X,T',Y) =
     X =/= Y and-then
    (vars(T)  == none and-then sortLeq(M,Y,X) or-else
     vars(T') == none and-then sortLeq(M,X,Y)) .
  eq groundLeastSortGreater(M,T,X:[Type],T',Y:[Type]) = false [owise] .

  --- PRE: Term is well-formed in Module
  --- OUT: The reduced term in the module
  op metaReduce2 : Module Term ~> Term .
  eq metaReduce2(M,T) = getTerm(metaReduce(M,T)) .

  --- OUT: Generate term from:
  ---      [1] OpDecl
  ---      [2] Fresh Variable Postfix
  --- PRE: OpDecl should not be poly
  op buildTerm : OpDecl Nat -> Term .
  eq buildTerm(op Q : YL -> Y [A:AttrSet].,N) = buildTerm(Q,N,YL,Y) .

  --- OUT: Generate term from:
  ---      [1] Operator Name
  ---      [2] Fresh Variable Postfix
  ---      [3] List of Types
  op buildTerm : Qid Nat TypeList Type -> Term .
  eq buildTerm(Q,N,Y YL,X) = Q[buildTerm'(N,Y YL)] .
  eq buildTerm(Q,N,nil ,X) = qid(string(Q) + "." + string(X)) .

  op buildTerm' : Nat TypeList -> TermList .
  eq buildTerm'(N,Y YL) = qid("@" + string(N,10) + ":" + string(Y)), buildTerm'(s(N),YL) .
  eq buildTerm'(N,nil ) = empty .

  op buildVar : Qid Type -> Variable .
  eq buildVar(Q,X) = qid(string(Q) + ":" + string(X)) .
endfm

fmod TERMLISTPAIR is
  pr META-LEVEL .

  sort TermListPair .
  op ((_,_)) : TermList TermList -> TermListPair [ctor] .
endfm

view TermListPair from TRIV to TERMLISTPAIR is sort Elt to TermListPair . endv

--- copy of code in FULL-MAUDE (fortunately, interpreter does not complain)
fmod TERMSET-FM is
  pr META-LEVEL .
  pr TERM-EXTRA .

  sort TermSet NeTermSet .
  subsort Term < NeTermSet < TermSet .
  op emptyTermSet : -> TermSet [ctor] .
  op _|_ : TermSet TermSet -> TermSet [ctor assoc comm id: emptyTermSet format (d n d d)] .
  op _|_ : TermSet NeTermSet -> NeTermSet [ctor ditto] .

  var U : Module .
  var T : Term . var TS : TermSet . var NTS : NeTermSet . var TL : TermList .
  var Y : Type .
  var V : Variable .
  var TQ : TermQid .
  var QS : QidSet .
  var O O' : OpDecl .
  var OS : OpDeclSet .
  var N : Nat .

  eq T | T = T .

  op |_| : TermSet -> Nat .
  op $card : TermSet Nat -> Nat .
  -------------------------------
  eq | TS | = $card(TS,0) .

  eq $card(T | TS,      N) = $card(TS,s(N)) .
  eq $card(emptyTermSet,N) = N .

  op _in_ : Term TermSet -> Bool .
  eq T in (T | TS) = true .
  eq T in TS = false [owise] .

  op TermSet : TermList -> TermSet .
  eq TermSet(empty) = emptyTermSet .
  eq TermSet((T,TL)) = T | TermSet(TL) .

  op setsize : TermSet -> Nat .
  eq setsize(T | TS) = s(size(TS)) .
  eq setsize(emptyTermSet) = 0 .

  --- OUT: return all terms in the termset that are less than
  ---      the given type
  op allInSort : Module TermSet Type -> TermSet .
  eq allInSort(U,T | TS,Y) =
    if sortLeq(U,leastSort(U,T),Y) then T else emptyTermSet fi |
    allInSort(U,TS,Y) .
  eq allInSort(U,emptyTermSet,Y) = emptyTermSet .

  --- OUT: return the set of TypeSet containing all the types
  ---      of the terms in this TermSet
  op tsleastSort : Module TermSet -> [TypeSet] .
  eq tsleastSort(U,emptyTermSet) = none .
  eq tsleastSort(U,T | NTS) = leastSort(U,T) ; tsleastSort(U,NTS) .

  --- OUT: a substitution built from mapping the variable to each term
  op tsBuildSub : Variable TermSet -> Substitution .
  eq tsBuildSub(V,T | TS) = V <- T ; tsBuildSub(V,TS) .
  eq tsBuildSub(V,emptyTermSet) = none .

  --- ### New
  op vars : TermSet -> QidSet .
  eq vars(T | NTS) = vars(T) ; vars(NTS) .
  eq vars(emptyTermSet) = none .

  --- ### New
  op termQidsToSet : QidSet -> TermSet .
  eq termQidsToSet(TQ ; QS) = TQ | termQidsToSet(QS) .
  eq termQidsToSet(none) = emptyTermSet .

  --- ### New
  --- OUT: true if each term in the set is well-formed
  op wellFormedSet : Module TermSet ~> Bool .
  eq wellFormedSet(U,T | TS) = wellFormed(U,T) and-then wellFormedSet(U,TS) .
  eq wellFormedSet(U,emptyTermSet) = true .

  op TermList : TermSet -> TermList .
  eq TermList(T | TS) = T,TermList(TS) .
  eq TermList(emptyTermSet) = empty .

  op buildTerm : OpDeclSet Nat -> TermSet .
  eq buildTerm(O O' OS,N) = buildTerm(O,N) buildTerm(O' OS,N) .
  eq buildTerm(none,N)    = emptyTermSet .
endfm

fmod TERMPAIRSET is
  pr META-LEVEL .
  sort TermPair TermPairSet .
  subsort TermPair < TermPairSet .
  op ((_:_))      : Term Term -> TermPair [ctor] .
  op _|_          : TermPairSet TermPairSet -> TermPairSet [ctor assoc comm id: .TermPairSet] .
  op .TermPairSet : -> TermPairSet [ctor] .
endfm

--- copy of code in FULL-MAUDE (fortunately, interpreter does not complain)
fmod UNIT-FM is
  inc META-LEVEL .

  op noModule : -> Module [ctor] .

  op emptyFModule : -> FModule .
  eq emptyFModule = fmod 'fmod is nil sorts none . none none none none endfm .
  op emptyFTheory : -> FModule .
  eq emptyFTheory = fth 'fth is nil sorts none . none none none none endfth .
  op emptySModule : -> SModule .
  eq emptySModule = mod 'mod is nil sorts none . none none none none none endm .
  op emptySTheory : -> SModule .
  eq emptySTheory = th 'th is nil sorts none . none none none none none endth .

  op getName : Module -> Header .
  op getPars : Module -> ParameterDeclList .

  op setName : Module ModuleExpression -> Module .
  op setName : Module ParameterDecl -> Module .
  op setPars : Module ParameterDeclList -> Module .
  op setImports : Module ImportList -> Module .
  op setSorts : Module SortSet -> Module .
  op setSubsorts : Module SubsortDeclSet -> Module .
  op setOps : Module OpDeclSet -> Module .
  op setMbs : Module MembAxSet -> Module .
  op setEqs : Module EquationSet -> Module .
  op setRls : Module RuleSet ~> Module .

  op addImports : ImportList Module -> Module .
  op addSorts : SortSet Module -> Module .
  op addSubsorts : [SubsortDeclSet] Module -> Module .
  op addOps : [OpDeclSet] Module -> Module .
  op addMbs : MembAxSet Module -> Module .
  op addEqs : EquationSet Module -> Module .
  op addRls : RuleSet Module -> Module .
  op addDecls : Module Module -> Module .

  vars M M' M'' : Module .
  vars SSDS SSDS' SSDS'' : SubsortDeclSet .
  vars OPD OPD' : OpDecl .
  vars OPDS OPDS' : OpDeclSet .
  vars MAS MAS' : MembAxSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' : EquationSet .
  vars Rl Rl' : Rule .
  vars RlS RlS' : RuleSet .
  vars SS SS' : SortSet .
  vars IL IL' : ImportList .
  vars PL PL' : ParameterList .
  vars U U' : Module .
  vars I I' : Import .
  vars ME ME' : ModuleExpression .
  vars PD PD' : ParameterDecl .
  vars PDL PDL' : ParameterDeclList .
  var  H H' : Header .

  eq getName(noModule) = ' .
  eq getName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getName(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = H .
  eq getName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getName(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = H .

  eq getImports(noModule) = nil .
  eq getImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = IL .
  eq getImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = IL .
  eq getImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = IL .
  eq getImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = IL .

  eq getPars(noModule) = nil .
  eq getPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = nil .
  eq getPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = PDL .
  eq getPars(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = nil .
  eq getPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPars(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = nil .

  eq getSorts(noModule) = none .
  eq getSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SS .
  eq getSorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SS .
  eq getSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SS .
  eq getSorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SS .

  eq getSubsorts(noModule) = none .
  eq getSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SSDS .
  eq getSubsorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SSDS .
  eq getSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SSDS .
  eq getSubsorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SSDS .

  eq getOps(noModule) = none .
  eq getOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = OPDS .
  eq getOps(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = OPDS .
  eq getOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = OPDS .
  eq getOps(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = OPDS .

  eq getMbs(noModule) = none .
  eq getMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = MAS .
  eq getMbs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = MAS .
  eq getMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = MAS .
  eq getMbs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = MAS .

  eq getEqs(noModule) = none .
  eq getEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = EqS .
  eq getEqs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = EqS .
  eq getEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = EqS .
  eq getEqs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = EqS .

  eq getRls(noModule) = none .
  eq getRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = RlS .
  eq getRls(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = RlS .
  eq getRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getRls(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .

  eq setImports(noModule, IL) = noModule .
  eq setImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, IL')
    = mod H is IL' sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, IL')
    = th H is IL' sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS OPDS MAS EqS endfm .
  eq setImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS OPDS MAS EqS endfth .

  eq setOps(noModule, OPDS) = noModule .
  eq setOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, OPDS')
    = mod H is IL sorts SS . SSDS OPDS' MAS EqS RlS endm .
  eq setOps(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, OPDS')
    = th H is IL sorts SS . SSDS OPDS' MAS EqS RlS endth .
  eq setOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, OPDS')
    = fmod H is IL sorts SS . SSDS OPDS' MAS EqS endfm .
  eq setOps(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, OPDS')
    = fth H is IL sorts SS . SSDS OPDS' MAS EqS endfth .

  eq setSubsorts(noModule, SSDS) = noModule .
  eq setSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SSDS')
    = mod H is IL sorts SS . SSDS' OPDS MAS EqS RlS endm .
  eq setSubsorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SSDS')
    = th H is IL sorts SS . SSDS' OPDS MAS EqS RlS endth .
  eq setSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SSDS')
    = fmod H is IL sorts SS . SSDS' OPDS MAS EqS endfm .
  eq setSubsorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, SSDS')
    = fth H is IL sorts SS . SSDS' OPDS MAS EqS endfth .

  eq setMbs(noModule, MAS) = noModule .
  eq setMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MAS')
    = mod H is IL sorts SS . SSDS OPDS MAS' EqS RlS endm .
  eq setMbs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MAS')
    = th H is IL sorts SS . SSDS OPDS MAS' EqS RlS endth .
  eq setMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MAS')
    = fmod H is IL sorts SS . SSDS OPDS MAS' EqS endfm .
  eq setMbs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, MAS')
    = fth H is IL sorts SS . SSDS OPDS MAS' EqS endfth .

  eq setEqs(noModule, EqS) = noModule .
  eq setEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, EqS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS' RlS endm .
  eq setEqs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, EqS')
    = th H is IL sorts SS . SSDS OPDS MAS EqS' RlS endth .
  eq setEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, EqS')
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS' endfm .
  eq setEqs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, EqS')
    = fth H is IL sorts SS . SSDS OPDS MAS EqS' endfth .

  eq setRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, RlS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS' endm .
  eq setRls(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, RlS')
    = th H is IL sorts SS . SSDS OPDS MAS EqS RlS' endth .
  eq setRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, RlS)
    = if RlS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setRls(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, RlS)
    = if RlS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      fi .

  eq setSorts(noModule, SS) = noModule .
  eq setSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SS')
    = mod H is IL sorts SS' . SSDS OPDS MAS EqS RlS endm .
  eq setSorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SS')
    = th H is IL sorts SS' . SSDS OPDS MAS EqS RlS endth .
  eq setSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SS')
    = fmod H is IL sorts SS' . SSDS OPDS MAS EqS endfm .
  eq setSorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, SS')
    = fth H is IL sorts SS' . SSDS OPDS MAS EqS endfth .

  eq setPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL)
    = if PDL == nil
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL')
    = if PDL' == nil
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setPars(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, PDL)
    = th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL)
    = if PDL == nil
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm
      fi .
  eq setPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL')
    = if PDL' == nil
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS endfm
      fi .
  eq setPars(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, PDL)
    = fth H is IL sorts SS . SSDS OPDS MAS EqS endfth .

  eq setName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, H')
    = fth H' is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, H')
    = th H' is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setName(noModule, ME) = noModule .

  eq addSorts(SS, U) = setSorts(U, (SS ; getSorts(U))) .
  eq addSorts(SS, noModule) = noModule .
  eq addSubsorts(SSDS, U) = setSubsorts(U, (SSDS getSubsorts(U))) .
  eq addSubsorts(SSDS, noModule) = noModule .
  eq addOps(OPDS, U) = setOps(U, (OPDS getOps(U))) .
  eq addMbs(MAS, U) = setMbs(U, (MAS getMbs(U))) .
  eq addMbs(MAS, noModule) = noModule .
  eq addEqs(EqS, U) = setEqs(U, (EqS getEqs(U))) .
  eq addEqs(EqS, noModule) = noModule .
  eq addRls(RlS, U) = setRls(U, (RlS getRls(U))) .
  eq addRls(RlS, noModule) = noModule .
  eq addImports(IL, U) = setImports(U, (getImports(U) IL)) .
  eq addImports(IL, noModule) = noModule .

  eq addDecls(noModule, U) = U .
  eq addDecls(U, noModule) = U .
  eq addDecls(U, U')
    = addImports(getImports(U'),
        addSorts(getSorts(U'),
          addSubsorts(getSubsorts(U'),
            addOps(getOps(U'),
              addMbs(getMbs(U'),
                addEqs(getEqs(U'),
                  if U' :: FModule or U' :: FTheory
                  then U
                  else addRls(getRls(U'),U)
                  fi))))))
    [owise] .

  op toFModule : Module -> FModule .
  eq toFModule(U) = addDecls(setName(emptyFModule,getName(U)),setRls(U,none)) .

  op getSig : Module -> Module .
  eq getSig(U) = setRls(setEqs(U,none),none) .
endfm

fmod BUBBLES is
  including QID-LIST .
  sorts @Token@ @SortToken@ @NeTokenList@ @Bubble@ .
  op token : Qid -> @Token@
    [special(
      id-hook Bubble (1 1)
      op-hook qidSymbol (<Qids> : ~> Qid))] .
  op sortToken : Qid -> @SortToken@
    [special(
       id-hook Bubble (1 1)
       op-hook qidSymbol (<Qids> : ~> Qid)
       id-hook Exclude ([ ] < to , . ( ) { } : |
                        ditto precedence prec gather
                        assoc associative comm commutative
                        ctor constructor id: strat strategy
                        poly memo memoization iter frozen
                        config object msg metadata nonexec variant))] .
  op neTokenList : QidList -> @NeTokenList@
    [special(
       id-hook Bubble (1 -1 ( ))
       op-hook qidListSymbol (__ : QidList QidList ~> QidList)
       op-hook qidSymbol (<Qids> : ~> Qid)
       id-hook Exclude (.))] .
  op bubble : QidList -> @Bubble@
    [special(
       id-hook Bubble (1 -1 ( ))
       op-hook qidListSymbol (__ : QidList QidList ~> QidList)
       op-hook qidSymbol (<Qids> : ~> Qid))] .
endfm

fmod SUBSTITUTION-HANDLING is
  protecting META-MODULE .

  var S S' Subst Subst' : Substitution .
  var V V' : Variable .
  var C C' : Constant .
  var Ct : Context .
  var T T' T1 T2 T1' T2' T1'' T2'' : Term .
  var F F' : Qid .
  var TL TL' TL1 TL2 TL1' TL2' : TermList .
  var Att : AttrSet .
  var RLS : RuleSet .
  var Rl : Rule .
  var TP : Type .
  var N : Nat .
  var NeTL : NeTermList .
  var CtL : NeCTermList .
  var ST : Sort .
  var Cnd : Condition .

  --- Apply Substitution to Term --------------------------------------------
  op _<<_ : Term Substitution -> Term .
  eq TL    << none                = TL .
  eq C     << Subst               = C .
  eq V     << ((V' <- T) ; Subst) = if V == V' then T else V << Subst fi .
  eq F[TL] << Subst               = F[TL << Subst] .

  op _<<_ : TermList Substitution -> TermList .
  eq (T, NeTL) << Subst = (T << Subst, NeTL << Subst) .
  eq empty     << Subst = empty .

  op _<<_ : Context Substitution -> Context .
  eq Ct << none = Ct .
  eq [] << Subst = [] .
  eq F[CtL,NeTL] << Subst = F[CtL << Subst,NeTL << Subst] .
  eq F[NeTL,CtL] << Subst = F[NeTL << Subst, CtL << Subst] .
  eq F[Ct] << Subst = F[Ct << Subst] .

  op _<<_ : Condition Substitution -> Condition .
  eq (T1  = T2 /\ Cnd) << S = (T1 << S)  = (T2 << S) /\ (Cnd << S) .
  eq (T1 := T2 /\ Cnd) << S = (T1 << S) := (T2 << S) /\ (Cnd << S) .
  eq (T1 :  ST /\ Cnd) << S = (T1 << S) :   ST       /\ (Cnd << S) .
  eq (T1 => T2 /\ Cnd) << S = (T1 << S) => (T2 << S) /\ (Cnd << S) .
  eq (nil).EqCondition << S = nil .

  op _<<_ : Substitution Substitution -> Substitution .
  eq S << (none).Substitution = S .
  eq (none).Substitution << S = (none).Substitution .
  eq ((V' <- T) ; S') <<  S
   = (V' <- (T << S))
     ;
     (S' << S) .

  --- Combine Substitutions -------------------------------------------------
  op _.._ : Substitution Substitution -> Substitution .
  eq S .. S' = (S << S') ; S' .

  --- Restrict Assignments to Variables in a Term ----------------------
  op _|>_ : Substitution TermList -> Substitution .

  eq Subst |> TL = Subst |>* Vars(TL) .

  op _|>*_ : Substitution TermList -> Substitution .
---   eq noMatch |>* TL = noMatch .
  eq Subst |>* TL = Subst |>** TL [none] .

  op _|>**_[_] : Substitution TermList
                 Substitution -> Substitution .
  eq none |>** TL [Subst']
   = Subst' .
  eq ((V <- V) ; Subst) |>** TL [Subst']
   = Subst |>** TL [Subst'] .
  eq ((V <- T') ; Subst) |>** TL [Subst']
    = Subst |>** TL
      [Subst' ; if any V in TL then (V <- T') else none fi] .

  --- Remove Variables from list ----------------------
  op _intersect_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) intersect (TL1',T,TL2')
   = (T,((TL1,TL2) intersect (TL1',TL2'))) .
  eq TL intersect TL' = empty [owise] .

  op _intersectVar_ : TermList TermList -> TermList .
  eq TL1 intersectVar TL2
   = TL1 intersectVar* Vars(TL2) .

  op _intersectVar*_ : TermList TermList -> TermList .
  eq (T,TL1) intersectVar* TL2
   = (if any Vars(T) in TL2 then T else empty fi,TL1 intersectVar* TL2) .
  eq empty intersectVar* TL2
   = empty .

  --- Remove Variables from list ----------------------
  op _setMinus_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) setMinus (TL1',T,TL2')
   = (TL1,TL2) setMinus (TL1',T,TL2') .
  eq TL setMinus TL' = TL [owise] .

  --- Variables ---
  op Vars : GTermList -> TermList .
  eq Vars((T,TL:GTermList)) = VarsTerm(T),Vars(TL:GTermList) .
  eq Vars((Ct,TL:GTermList)) = VarsTerm(Ct),Vars(TL:GTermList) .
  eq Vars(empty) = empty .

  op VarsTerm : Term -> TermList . ---warning memo
  eq VarsTerm(V) = V .
  eq VarsTerm(F[TL:TermList]) = Vars(TL:TermList) .
  eq VarsTerm(C) = empty .

  op VarsTerm : Context -> TermList . ---warning memo
  eq VarsTerm(F[TL:GTermList]) = Vars(TL:GTermList) .

  --- membership ---
  op _in_ : Term TermList -> Bool .
  eq T in (TL,T,TL') = true .
  eq T in TL = false [owise] .

  --- membership ---
  op any_in_ : TermList TermList -> Bool . --- [memo] .
  eq any empty in TL = false .
  eq any (TL1,T,TL2) in (TL1',T,TL2') = true .
  eq any TL in TL' = false [owise] .

  --- membership ---
  op all_in_ : TermList TermList -> Bool . --- [memo] .
  eq all empty in TL = true .
  eq all (TL1,T,TL2) in (TL1',T,TL2') = all (TL1,TL2) in (TL1',T,TL2') .
  eq all TL in TL' = false [owise] .

  --- Occur check ---
  op allVars_inVars_ : GTermList GTermList -> Bool .
  eq allVars TL:GTermList inVars TL':GTermList
   = all Vars(TL:GTermList) in Vars(TL':GTermList) .

  op anyVars_inVars_ : GTermList GTermList -> Bool .
  eq anyVars TL:GTermList inVars TL':GTermList
   = any Vars(TL:GTermList) in Vars(TL':GTermList) .

  op rangeVars : Substitution -> TermList .
  eq rangeVars(V <- T ; Subst) = (Vars(T),rangeVars(Subst)) .
  eq rangeVars(none) = empty .

  op dom_inVars_ : Substitution TermList -> Bool .
  eq dom Subst inVars TL = dom Subst in Vars(TL) .

  op dom_in_ : Substitution TermList -> Bool .
  eq dom (V <- T ; Subst) in (TL1,V,TL2) = true .
  eq dom Subst in TL = false [owise] .

  op dom_notInVars_ : Substitution TermList -> Bool .
  eq dom Subst notInVars TL = dom Subst notIn Vars(TL) .

  op dom_notIn_ : Substitution TermList -> Bool .
  eq dom none notIn TL = true .
 ceq dom (V <- T ; Subst) notIn TL = true if not (V in TL) .
  eq dom Subst notIn TL = false [owise] .

  op range_inVars_ : Substitution TermList -> Bool .
  eq range Subst inVars TL = range Subst in Vars(TL) .

  op range_in_ : Substitution TermList -> Bool .
  eq range (V <- T ; Subst) in TL
   = any Vars(T) in TL or-else range Subst in TL .
  eq range none in TL
   = false .

  op valid-occur-check? : Substitution -> Bool .
  eq valid-occur-check?(Subst)
   = not (dom Subst inVars (rangeVars(Subst))) .

  op extract-bindings : Substitution -> TermList .
  eq extract-bindings(none) = empty .
  eq extract-bindings(V <- T ; Subst) = (T,extract-bindings(Subst)) .
endfm

fmod SUBSTITUTIONSET is
  protecting SUBSTITUTION-HANDLING .
  protecting TERMSET-FM .

  sort SubstitutionSet NeSubstitutionSet .
  subsort Substitution < NeSubstitutionSet < SubstitutionSet .
  op empty : -> SubstitutionSet [ctor] .
  op _|_ : SubstitutionSet SubstitutionSet -> SubstitutionSet
    [ctor assoc comm id: empty format (d n d d)] .
  op _|_ : NeSubstitutionSet SubstitutionSet -> NeSubstitutionSet
    [ctor ditto] .
  eq X:Substitution | X:Substitution = X:Substitution .

  vars SS SS' : SubstitutionSet .
  vars S S' Subst : Substitution .
  vars T T' : Term .
  vars TL TL' : TermList .
  vars N N' : Nat .
  var V : Variable .

  op _<<_ : Substitution SubstitutionSet -> SubstitutionSet .
  eq S << empty = empty .
  ceq S << (S' | SS') = (S << S') | (S << SS') if SS' =/= empty .

  op _..._ : SubstitutionSet [SubstitutionSet]
          -> SubstitutionSet [strat (1) gather (e E)] .

  eq empty ... SS':[SubstitutionSet] = empty .
  eq (S | SS) ... SS':[SubstitutionSet]
   = (S ...' SS':[SubstitutionSet])
     |
     (SS ... SS':[SubstitutionSet]) .

  op _...'_ : Substitution SubstitutionSet -> SubstitutionSet .

  eq S ...' empty
   = empty .

  eq S ...' (S' | SS')
   = (S .. S')
     |
     (S ...' SS') .

  op anySub : NeSubstitutionSet -> Substitution .
  eq anySub(S | SS) = S .
endfm

fmod VARIANT is
  pr SUBSTITUTIONSET .
  pr META-LEVEL .

  var M : Module .
  vars T T' TS TS' CtTS CtTS' Lhs Rhs : Term .
  vars N N' NextVar NextVar' NextVar'' : Nat .
  var B : Bound .
  var TL TL' : TermList .
  var NeTL : NeTermList .
  var EqS : EquationSet .
  var AtS : AttrSet .
  var Q : Qid .
  vars S S' : Substitution .
  var V : Variable .
  vars TP TP' : Type .
  var C : Constant .
  vars F F' : Qid .


  sort VariantTripleSet .
  subsort Variant < VariantTripleSet .

  op empty : -> VariantTripleSet [ctor] .
  op _|_ : VariantTripleSet VariantTripleSet -> VariantTripleSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
  eq X:Variant | X:Variant = X:Variant .

  op getTerms : VariantTripleSet -> TermSet .
  eq getTerms({T:Term,S:Substitution,NextVar:Nat,P:Parent,B:Bool}
              | R:VariantTripleSet)
   = T:Term | getTerms(R:VariantTripleSet) .
  eq getTerms((empty).VariantTripleSet)
   = emptyTermSet .

  op getSubstitutions : VariantTripleSet -> SubstitutionSet .
  eq getSubstitutions({T:Term,S:Substitution,NextVar:Nat,P:Parent,B:Bool}
              | R:VariantTripleSet) = S:Substitution | getSubstitutions(R:VariantTripleSet) .
  eq getSubstitutions((empty).VariantTripleSet)
   = empty .
endfm

fmod KIND-CHECK is
  pr META-LEVEL .

  --- copy of or-else to make eqs more readable
  op _orL_ : Bool Bool -> Bool [strat (1 0) gather (e E) prec 59] .

  op kinds? : TypeListSet -> Bool .
  op kinds? : Module Bool TermList -> Bool .
  op kinds? : Module Bool AttrSet -> Bool .
  op kinds? : Module Bool Condition -> Bool .
  op kinds? : Module Bool OpDeclSet -> Bool .
  op kinds? : Module Bool MembAxSet -> Bool .
  op kinds? : Module Bool EquationSet -> Bool .
  op kinds? : Module Bool RuleSet -> Bool .
  op kinds? : Bool Module -> Bool .

  var FM     : FModule .
  var FT     : FTheory .
  var SM     : SModule .
  var ST     : STheory .
  var M      : Module .
  var K      : Kind .
  var S      : Sort .
  var SS     : SortSet .
  var T      : Type .
  var TL TL' : TypeList .
  var NTL    : NeTypeList .
  var TS     : TypeListSet .
  var C      : Constant .
  var V      : Variable .
  var TML    : TermList .
  var NTML   : NeTermList .
  var Q      : Qid .
  var AS     : AttrSet .
  var CN     : Condition .
  var TM TM' : Term .
  var O O'   : OpDecl .
  var OS     : OpDeclSet .
  var E E'   : Equation .
  var ES     : EquationSet .
  var MB MB' : MembAx .
  var MBS    : MembAxSet .
  var R R'   : Rule .
  var RS     : RuleSet .
  var B      : Bool .

  eq true orL B = true .
  eq false orL B = B .

  eq kinds?(K)                  = true .
  eq kinds?(S)                  = false .
  eq kinds?(T NTL)              = kinds?(T) orL kinds?(NTL) .
  eq kinds?(nil)                = false .
  eq kinds?(TL ; TL' ; TS)      = kinds?(TL) orL kinds?(TL' ; TS) .
  eq kinds?((none).TypeListSet) = false .

  eq kinds?(M,B,C)         = getType(C) :: Kind .
  eq kinds?(M,B,V)         = getType(V) :: Kind .
  eq kinds?(M,B,Q[NTML])   = (B and-then (leastSort(M,Q[NTML]) :: Kind)) orL kinds?(M,B,NTML) .
  eq kinds?(M,B,(TM,NTML)) = kinds?(M,B,TM) orL kinds?(M,B,NTML) .
  eq kinds?(M,B,empty)     = false .

  eq kinds?(M,B,id(T) AS)       = kinds?(M,B,T) orL kinds?(M,B,AS) .
  eq kinds?(M,B,left-id(T) AS)  = kinds?(M,B,T) orL kinds?(M,B,AS) .
  eq kinds?(M,B,right-id(T) AS) = kinds?(M,B,T) orL kinds?(M,B,AS) .
  eq kinds?(M,B,AS)             = false [owise] .

  eq kinds?(M,B,TM = TM' /\ CN)  = kinds?(M,B,(TM,TM')) orL kinds?(M,B,CN) .
  eq kinds?(M,B,TM : S /\ CN)    = kinds?(M,B,TM) orL kinds?(M,B,CN) .
  eq kinds?(M,B,TM := TM' /\ CN) = kinds?(M,B,(TM,TM')) orL kinds?(M,B,CN) .
  eq kinds?(M,B,TM => TM' /\ CN) = kinds?(M,B,(TM,TM')) orL kinds?(M,B,CN) .
  eq kinds?(M,B,(nil).Condition) = false .

  eq kinds?(M,B,op Q : TL -> T [AS].) = kinds?(TL T) orL kinds?(M,B,AS) .
  eq kinds?(M,B,O O' OS)              = kinds?(M,B,O) orL kinds?(M,B,O' OS) .
  eq kinds?(M,B,(none).OpDeclSet)     = false .

  eq kinds?(M,B,mb TM : S [AS].)        = kinds?(M,B,TM) orL kinds?(M,B,AS) .
  eq kinds?(M,B,cmb TM : S if CN [AS].) = kinds?(M,B,TM) orL kinds?(M,B,CN) orL kinds?(M,B,AS) .
  eq kinds?(M,B,MB MB' MBS)             = kinds?(M,B,MB) orL kinds?(M,B,MB' MBS) .
  eq kinds?(M,B,(none).MembAxSet)       = false .

  eq kinds?(M,B,eq TM = TM' [AS].)        = kinds?(M,B,(TM,TM')) orL kinds?(M,B,AS) .
  eq kinds?(M,B,ceq TM = TM' if CN [AS].) = kinds?(M,B,(TM,TM')) orL kinds?(M,B,CN) orL kinds?(M,B,AS) .
  eq kinds?(M,B,E E' ES)                  = kinds?(M,B,E) orL kinds?(M,B,E' ES) .
  eq kinds?(M,B,(none).EquationSet)       = false .

  eq kinds?(M,B,rl TM => TM' [AS].)        = kinds?(M,B,(TM,TM')) orL kinds?(M,B,AS) .
  eq kinds?(M,B,crl TM => TM' if CN [AS].) = kinds?(M,B,(TM,TM')) orL kinds?(M,B,CN) orL kinds?(M,B,AS) .
  eq kinds?(M,B,R R' RS)                   = kinds?(M,B,R) orL kinds?(M,B,R' RS) .
  eq kinds?(M,B,(none).RuleSet)            = false .

  eq kinds?(B,FM) =
    kinds?(FM,B,getOps(FM)) orL
    kinds?(FM,B,getMbs(FM)) orL
    kinds?(FM,B,getEqs(FM)) .

  eq kinds?(B,FT) =
    kinds?(FT,B,getOps(FT)) orL
    kinds?(FT,B,getMbs(FT)) orL
    kinds?(FT,B,getEqs(FT)) .

  eq kinds?(B,SM) =
    kinds?(SM,B,getOps(SM)) orL
    kinds?(SM,B,getMbs(SM)) orL
    kinds?(SM,B,getEqs(SM)) orL
    kinds?(SM,B,getRls(SM)) .

  eq kinds?(B,ST) =
    kinds?(ST,B,getOps(ST)) orL
    kinds?(ST,B,getMbs(ST)) orL
    kinds?(ST,B,getEqs(ST)) orL
    kinds?(ST,B,getRls(ST)) .
endfm

fmod GTERMLIST-REFINEMENT is
  pr META-TERM .
  sort GTerm NeGTermList .
  subsort Term Context < GTerm   < NeGTermList < GTermList .
  subsort NeTermList NeCTermList < NeGTermList .
  op _,_ : NeGTermList GTermList -> NeGTermList [ctor ditto] .
  op _,_ : GTermList NeGTermList -> NeGTermList [ctor ditto] .
endfm

fmod SUBSTITUTION-REFINEMENT is
  pr QIDSET-REFINEMENT    .
  pr GTERMLIST-REFINEMENT .
  sort VarAssignment ConstAssignment GroundAssignment .
  sort EmptySubstitution VarSubstitution ConstSubstitution GroundSubstitution .
  subsort ConstAssignment < GroundAssignment .
  subsort VarAssignment   ConstAssignment   GroundAssignment   < Assignment .
  subsort EmptySubstitution < VarSubstitution ConstSubstitution GroundSubstitution < Substitution .
  subsort ConstSubstitution < GroundSubstitution .
  subsort VarAssignment     < VarSubstitution .
  subsort ConstAssignment   < ConstSubstitution .
  subsort GroundAssignment  < GroundSubstitution .
  op _<-_ : Variable Variable                     -> VarAssignment       [ctor ditto] .
  op _<-_ : Variable Constant                     -> ConstAssignment     [ctor ditto] .
  op _<-_ : Variable GroundTerm                   -> GroundAssignment    [ctor ditto] .
  op none :                                       -> EmptySubstitution   [ctor ditto] .
  op _;_  : EmptySubstitution  EmptySubstitution  -> EmptySubstitution   [ctor ditto] .
  op _;_  : VarSubstitution    VarSubstitution    -> VarSubstitution     [ctor ditto] .
  op _;_  : ConstSubstitution  ConstSubstitution  -> ConstSubstitution   [ctor ditto] .
  op _;_  : GroundSubstitution GroundSubstitution -> GroundSubstitution  [ctor ditto] .
  op errsub : QidList -> [Substitution] .

  op errsubMsg : [Substitution] -> QidList .
  eq errsubMsg(errsub(QL:QidList)) = QL:QidList .
  eq errsubMsg(S:[Substitution]) = nil .
endfm

fmod SUBSTITUTIONPAIR is
  pr SUBSTITUTION-REFINEMENT .
  pr SUBSTITUTIONSET .
  sort SubstitutionPair SubstitutionSetPair .
  subsort SubstitutionPair < SubstitutionSetPair .
  op ((_,_)) : Substitution Substitution       -> SubstitutionPair    [ctor] .
  op ((_,_)) : SubstitutionSet SubstitutionSet -> SubstitutionSetPair [ctor] .
  ops p1 p2 : SubstitutionPair    -> Substitution .
  ops p1 p2 : SubstitutionSetPair -> SubstitutionSet .
  var S1 S2 : SubstitutionSet .
  eq p1((S1,S2)) = S1 .
  eq p2((S1,S2)) = S2 .
endfm

fmod SUBSTITUTIONSETPAIR is pr SUBSTITUTIONPAIR . endfm

fmod SUBSTITUTIONPAIRSET is
  pr SUBSTITUTIONPAIR .
  sort SubstitutionPairSet NeSubstitutionPairSet .
  subsort SubstitutionPair < NeSubstitutionPairSet < SubstitutionPairSet .
  op empty : -> SubstitutionPairSet [ctor] .
  op _|_ : SubstitutionPairSet SubstitutionPairSet -> SubstitutionPairSet
    [ctor assoc comm id: empty format (d n d d)] .
  op _|_ : NeSubstitutionPairSet SubstitutionPairSet -> NeSubstitutionPairSet
    [ctor ditto] .
  eq X:SubstitutionPair | X:SubstitutionPair = X:SubstitutionPair .
endfm

fmod SUBSTITUTION-AUX is
  pr SUBSTITUTION-REFINEMENT .
  pr SUBSTITUTION-HANDLING   .
  pr TERM-EXTRA              . --- defines vars()
  pr MAYBE-QID               . --- defines noqid
  op idsub       : VariableSet               -> VarSubstitution .
  op domain      : Substitution              -> VariableSet .
  op range       : Substitution              -> VariableSet .
  op filterNotIn : Substitution VariableSet  -> Substitution .
  op filterIn    : Substitution VariableSet  -> Substitution .
  op bound       : Variable Substitution     -> Bool .
  op remove      : Substitution  Substitution -> Substitution  .
  op remove      : Substitution? Substitution -> Substitution? .

  var V V' V2 : Variable . var T : Term . var S S' : Substitution . var VS : VariableSet . var A : Assignment .
  var U : Module . var VSub : VarSubstitution . var B : Bool .

  --- INP: QidSet
  --- PRE: None
  --- OUT: Identity substitution over VariableSet
  eq idsub(V ; VS) = V <- V ; idsub(VS) .
  eq idsub(none)   = none .

  --- INP: Substitution
  --- PRE: None
  --- OUT: VariableSet composed of variables mapped to other values
  eq domain(V <- T ; S) = V ; domain(S) .
  eq domain(none)       = none .

  --- INP: Substitution
  --- PRE: None
  --- OUT: VariableSet containing all variables in codomain of substitution
  eq range(V <- T ; S) = vars(T) ; range(S) .
  eq range(none)       = none .

  --- INP: Subsitution VS:QidSet
  --- PRE: None
  --- OUT: Substitution where each binding V <- T is
  ---      filtered out if V occurs in VS
  eq filterNotIn(V <- T ; S,VS) = if V in VS then none else V <- T fi ; filterNotIn(S,VS) .
  eq filterNotIn(none,VS)       = none .
  ---
  eq filterIn(V <- T ; S,VS) = if V in VS then V <- T else none fi ; filterIn(S,VS) .
  eq filterIn(none,VS)       = none .

  --- INP: Variable Substitution
  --- PRE: None
  --- OUT: True iff variable is bound by substitution
  eq bound(V,V <- T ; S) = true          .
  eq bound(V,S)          = false [owise] .

  --- INP: Substitution1 Substitution2
  --- PRE: None
  --- OUT: a new Substitution identical to Substiution1 but where any assignment in Substitution2 has been removed
  eq remove(S ; A,A ; S') = remove(S,A ; S') .
  eq remove(S,S')         = S [owise] .
  eq remove(noMatch,S')   = noMatch .


  --- OUT: Generate range of variables as generated by the substitution.
  op captureNewVars : VariableSet Substitution  -> VariableSet .
  eq captureNewVars(V ; VS,S) = vars(V << S) ; captureNewVars(VS,S) .
  eq captureNewVars(none,S) = none .

  --- OUT: If Bool is true, substitution S with domain ENTIRELY replaced by a VarSubstitution which is a subset of S'
  ---      If Bool is false, subtitution S with domain PARTIALLY replaced by a VarSubstitution which is a subset of S'
  op renameDom : Bool Substitution Substitution ~> Substitution .
  eq renameDom(B,S,S') = renameDom'(B,S,none,filterIn(S',domain(S))) .

  op renameDom' : Bool Substitution Substitution VarSubstitution ~> Substitution .
  eq renameDom'(B,    V <- T ; S,S',V <- V' ; VSub) = renameDom'(B,S,S' ; V' <- T,VSub) .
  eq renameDom'(true, none      ,S',          VSub) = S' .
  eq renameDom'(false,S         ,S',          VSub) = S ; S' [owise] .

  --- OUT: invert a substitution mapping variables to variables
  op invert : VarSubstitution -> VarSubstitution .
  eq invert(V <- V' ; VSub) = V' <- V ; invert(VSub) .
  eq invert(none) = none .

  op getRenaming : Variable VarSubstitution -> MaybeQid .
  eq getRenaming(V,V' <- V2 ; VSub) = if V == V' then V2 else getRenaming(V,VSub) fi .
  eq getRenaming(V,none)            = noqid .
endfm

fmod TYPE-EXTRA is
  pr META-LEVEL .

  --- BASIC TYPE OPERATIONS
  op direct-subsorts   : Module Type -> SortSet .
  op direct-subsorts   : SubsortDeclSet Type -> SortSet .

  --- BASIC TYPE SET OPERATIONS
  op getMaximalSorts   : Module -> SortSet .
  op getMaximalSorts   : Module KindSet -> SortSet .

  --- BASIC TYPE TUPLE OPERATIONS
  --- Folds over set with _and_
  op $typeLeq          : Module TypeList TypeList -> Bool .
  op $typeLeqS         : Module TypeList TypeListSet -> Bool .
  op typeLeqS          : Module TypeListSet TypeListSet -> Bool .
  --- Folds over set with _or_
  op $anyTypeLeqS      : Module TypeList TypeListSet -> Bool .
  op anyTypeLeqS       : Module TypeListSet TypeListSet -> Bool .
  --- Folds over the set with _and_
  op $typeRel          : Module TypeList TypeList -> Bool .
  op $typeRelS         : Module TypeList TypeListSet -> Bool .
  op typeRelS          : Module TypeListSet TypeListSet -> Bool .
  --- Other operators
  op greaterSorts      : Module Sort -> SortSet .
  op $greaterSorts     : Module Sort SortSet -> SortSet .
  op minimalSorts2     : Module SortSet -> SortSet .
  op minimalSorts2     : Module SortSet SortSet SortSet -> SortSet .
  op ubSorts           : Module SortSet -> SortSet .
  op $ubSorts          : Module SortSet SortSet -> SortSet .
  op lubSort           : Module SortSet ~> Sort .
  op $lubSort          : SortSet ~> Sort .

  --- BASIC TYPE TUPLE SET OPERATIONS
  op _in_              : TypeList TypeListSet -> Bool .
  op _-_               : TypeListSet TypeListSet -> TypeListSet .
  op $tydiff           : TypeListSet TypeListSet TypeListSet -> TypeListSet .
  op intersect         : TypeListSet TypeListSet -> TypeListSet .

  --- TYPE TUPLE AUXILLIARY OPERATIONS
  op merge             : TypeListSet TypeListSet -> TypeListSet .
  op $merge1           : TypeListSet TypeListSet TypeListSet -> TypeListSet .
  op $merge2           : TypeList TypeListSet TypeListSet -> TypeListSet .

  --- CONVERSIONS
  op typeListToSet     : TypeList -> TypeSet .

  --- DECL TYPE OPERATIONS
  op possibleTypings   : Module Qid -> TypeSet .

  var SDS : SubsortDeclSet .
  var TYLS TYLS' TYLS'' : TypeListSet .
  var TYS : TypeSet .
  var TY TY' : Type .
  var S S' : Sort .
  var K K' : Kind .
  var KS : KindSet .
  var TYL TYL' TYL'' : TypeList .
  var SS SS' SS2 : SortSet .
  var M : Module .
  var Q Q' : Qid .
  var ODS : OpDeclSet .
  var AS : AttrSet .
  var T : Term .
  var TL : TermList .

  --- INP: Module Type
  --- PRE: Type is well-defined in Module
  --- OUT: Set of direct subsorts of Type
  eq direct-subsorts(M,S) = direct-subsorts(getSubsorts(M),S) .
  eq direct-subsorts(M,K) = maximalSorts(M,K) .
  eq direct-subsorts(SDS subsort S' < S .,S) = S' ; direct-subsorts(SDS,S) .
  eq direct-subsorts(SDS,TY) = none [owise] .

  --- INP: Module [KindSet]
  --- PRE: Kinds are well-defined in Module
  --- OUT: Set of maximal sorts of each kind
  eq getMaximalSorts(M)        = getMaximalSorts(M,getKinds(M)) .
  eq getMaximalSorts(M,K ; KS) = maximalSorts(M,K) ; getMaximalSorts(M,KS) .
  eq getMaximalSorts(M,none)   = none .

  --- INP: Module TypeListSet1 TypeListSet2
  --- PRE: Types in TypeLists are defined in Module
  --- OUT: true if every type in TypeListSet1 is a subtype of TypeListSet2
  eq $typeLeq(M,K TYL,S TYL')  = false .
  eq $typeLeq(M,S TYL,K TYL')  = sortLeq(M,S,K)  and-then $typeLeq(M,TYL,TYL') .
  eq $typeLeq(M,K TYL,K' TYL') = sortLeq(M,K,K') and-then $typeLeq(M,TYL,TYL') .
  eq $typeLeq(M,S TYL,S' TYL') = sortLeq(M,S,S') and-then $typeLeq(M,TYL,TYL') .
  eq $typeLeq(M,nil,nil)       = true .
  eq $typeLeq(M,TYL,TYL')      = false [owise] .
  eq $typeLeqS(M,TYL,TYL' ; TYLS) =
    $typeLeq(M,TYL,TYL') and-then $typeLeqS(M,TYL,TYLS) .
  eq $typeLeqS(M,TYL,none) = true .
  eq typeLeqS(M,TYL ; TYLS,TYLS') =
    $typeLeqS(M,TYL,TYLS') and-then typeLeqS(M,TYLS,TYLS') .
  eq typeLeqS(M,none,TYLS') = true .

  --- NB: Same as above but folding with _or_ instead of _and_
  eq $anyTypeLeqS(M,TYL,TYL' ; TYLS) =
    $typeLeq(M,TYL,TYL') or-else $anyTypeLeqS(M,TYL,TYLS) .
  eq $anyTypeLeqS(M,TYL,none) = false .
  eq anyTypeLeqS(M,TYL ; TYLS,TYLS') =
    $anyTypeLeqS(M,TYL,TYLS') or-else anyTypeLeqS(M,TYLS,TYLS') .
  eq anyTypeLeqS(M,none,TYLS') = false .

  --- INP:  Module TypeListSet1 TypeListSet2
  --- PRE:  Types in TypeLists are defined in Module
  --- OUT:  true if corresponding types in each typelist have the same kind
  --- NOTE: the mnemonic typeRel stands for type related
  eq $typeRel(M,TY TYL,TY' TYL') = sameKind(M,TY,TY') and $typeRel(M,TYL,TYL') .
  eq $typeRel(M,nil,nil)         = true .
  eq $typeRel(M,TYL,TYL')        = false [owise] .
  eq $typeRelS(M,TYL,TYL' ; TYLS) =
    $typeRel(M,TYL,TYL') and-then $typeRelS(M,TYL,TYLS) .
  eq $typeRelS(M,TYL,none) = true .
  eq typeRelS(M,TYL ; TYLS,TYLS') =
    $typeRelS(M,TYL,TYLS') and-then typeRelS(M,TYLS,TYLS') .
  eq typeRelS(M,none,TYLS') = true .

  --- INP: Module Sort
  --- PRE: Type is defined in Module
  --- OUT: SortSet of all types greater than Sort
  eq greaterSorts(M,S) = $greaterSorts(M,S,lesserSorts(M,getKind(M,S))) .
  eq $greaterSorts(M,S,S' ; SS) =
    if sortLeq(M,S,S') then
      S' ; $greaterSorts(M,S,SS)
    else
      $greaterSorts(M,S,SS)
    fi .
  eq $greaterSorts(M,S,none) = none .

  --- PRE: Sorts are well-defined in Module
  --- OUT: The subset of minimal sorts in the set
  eq minimalSorts2(M,SS) = minimalSorts2(M,SS,none,none) .

  --- NB: we induct over SS, SS' are non-minimal, SS2 are minimal
  eq minimalSorts2(M,S ; SS,SS',SS2) =
    if anyTypeLeqS(M,SS ; SS',S)
      then minimalSorts2(M,SS,S ; SS',    SS2)
      else minimalSorts2(M,SS,    SS',S ; SS2)
    fi .
  eq minimalSorts2(M,none,SS',SS2) = SS2 .

  --- PRE: Sorts are well-defined in Module
  --- OUT: The set of sorts that are upper bounds of the sort set
  op ubSorts : Module SortSet -> SortSet .
  eq ubSorts(M,SS) = $ubSorts(M,getSorts(M),SS) .

  op $ubSorts : Module SortSet SortSet -> SortSet .
  eq $ubSorts(M,S' ; SS',SS) =
    if typeLeqS(M,SS,S') then S' else none fi ;
    $ubSorts(M,SS',SS) .
  eq $ubSorts(M,none,SS) = none .

  --- PRE: Sorts are well-defined in Module
  --- OUT: The unique least upper bound sort, if it exists
  eq lubSort(M,SS) = $lubSort(minimalSorts2(M,ubSorts(M,SS))) .
  eq $lubSort(S) = S .

  --- INP: TypeList TypeListSet
  --- PRE: None
  --- OUT: true iff TypeList is in TypeListSet
  eq TYL in (TYL ; TYLS) = true .
  eq TYL in TYLS = false [owise] .

  --- INP: TypeListSet1 TypeListSet2
  --- PRE: None
  --- OUT: TypeListSet containing all TypeLists in TypeListSet1 and not in
  ---      TypeListSet2
  eq TYLS - TYLS' = $tydiff(TYLS,TYLS',none) .
  eq $tydiff(TYL ; TYLS,TYLS',TYLS'') =
    if TYL in TYLS' then
      $tydiff(TYLS,TYLS',TYLS'')
    else
      $tydiff(TYLS,TYLS',TYL ; TYLS'')
    fi .
  eq $tydiff(none,TYLS',TYLS'') = TYLS'' .

  --- INP: TypeListSet1 TypeListSet2
  --- PRE: None
  --- OUT: TypeListSet containing all items in both sets
  eq intersect(TYL ; TYLS,TYLS') =
    if TYL in TYLS' then
      TYL ; intersect(TYLS,TYLS')
    else
      intersect(TYLS,TYLS')
    fi .
  eq intersect(none,TYLS') = none .

  --- INP: TypeListSet TypeListSet
  --- PRE: None
  --- OUT: A TypeListSet formed by merging each pair of TypeLists
  ---      in the two TypeListSets
  eq merge(TYLS,TYLS') = $merge1(TYLS,TYLS',none) .
  eq $merge1(TYL ; TYLS, TYLS', TYLS'') =
    $merge1(TYLS, TYLS', $merge2(TYL,TYLS',none) ; TYLS'') .
  eq $merge1(none,TYLS',TYLS'') = TYLS'' .
  eq $merge2(TYL, TYL' ; TYLS, TYLS') =
    $merge2(TYL, TYLS, TYL TYL' ; TYLS') .
  eq $merge2(TYL, none, TYLS') = TYLS' .

  --- INP: TypeList
  --- PRE: None
  --- OUT: Turns a TypeList into the corresponding TypeSet
  eq typeListToSet(TY TYL) = TY ; typeListToSet(TYL) .
  eq typeListToSet(nil)    = none .

  --- INP: Module Qid
  --- PRE: None
  --- OUT: Possible result types of operators with name Qid
  op possibleTypings : OpDeclSet Qid -> TypeSet .
  eq possibleTypings(M,Q) = possibleTypings(getOps(M),Q) .
  eq possibleTypings(op Q' : TYL -> TY [AS]. ODS,Q) =
    if Q == Q' then
      TY ; possibleTypings(ODS,Q)
    else
      possibleTypings(ODS,Q)
    fi .
  eq possibleTypings(none,Q) = none .

  --- INP: Module TypeList
  --- PRE: TypeList defined in Module
  --- OUT: TypeListSet of all TypeLists less than the current one
  op typesBelow        : Module TypeList -> TypeListSet .
  op $typesBelow       : Module TypeList TypeListSet -> TypeListSet .
  eq typesBelow(M,TYL) = $typesBelow(M,TYL,nil) .
  eq $typesBelow(M,TY TYL,TYLS) = $typesBelow(M,TYL,merge(TYLS,lesserSorts(M,TY) ; TY)) .
  eq $typesBelow(M,nil,TYLS) = TYLS .

  --- INP: Module TypeList
  --- PRE: TypeList well-defined in Module
  --- OUT: KindList corresponding to this TypeList
  op toKind : Module TypeList -> TypeList .
  eq toKind(M,TY TYL) = completeName(M,getKind(M,TY)) toKind(M,TYL) .
  eq toKind(M,nil) = nil .

  --- PRE: Term well-defined in Module
  --- OUT: A TypeList with n elements corresponding to n terms' types in termlist
  op termListTypes : Module TermList -> TypeList .
  eq termListTypes(M,(T, TL))  = leastSort(M,T) termListTypes(M,TL) .
  eq termListTypes(M,empty) = nil .

  --- OUT: return a maximal sort above the given sort
  ---  NB: output is not guaranteed to be stable across executions
  op maximalSortAbove : Module Sort ~> Sort .
  op maximalSortAbove : Module Sort SortSet ~> Sort .
  eq maximalSortAbove(M,S) = maximalSortAbove(M,S,maximalSorts(M,getKind(M,S))) .
  eq maximalSortAbove(M,S,S' ; SS) =
    if sortLeq(M,S,S')
      then ---if maximalSortAbove(M,S,SS) :: Sort
        ---then maximalSortAbove(M,S,none)
        S' ---else S' fi
      else maximalSortAbove(M,S,SS)
    fi .
endfm

fmod ATTR-EXTRA is
  pr META-MODULE .

  ops special-attr id-attr left-id-attr right-id-attr
      strat-attr frozen-attr poly-attr prec-attr gather-attr
      format-attr print-attr label-attr metadata-attr : -> Attr .
  op _%_ : AttrSet AttrSet -> AttrSet .
  op _-_ : AttrSet AttrSet -> AttrSet .
  op in  : AttrSet AttrSet -> Bool .

  var A A' : Attr .
  var Q Q' : Qid .
  var QL QL' : QidList .
  var TYL : TypeList .
  var TY : Type .
  var AS AS' : AttrSet .
  var S S' : String .
  var N N' : Nat .
  var NL NL' : NatList .
  var HL HL' : NeHookList .
  var T T' : Term .

  --- INP: None
  --- PRE: None
  --- OUT: Attrs for use in _%_
  eq special-attr  = special(term-hook('T,'T.S)) .
  eq id-attr       = id('T.S) .
  eq left-id-attr  = left-id('T.S) .
  eq right-id-attr = right-id('T.S) .
  eq strat-attr    = strat(0) .
  eq frozen-attr   = frozen(0) .
  eq poly-attr     = poly(0) .
  eq prec-attr     = prec(0) .
  eq gather-attr   = gather(nil) .
  eq format-attr   = format(nil) .
  eq print-attr    = print(nil) .
  eq label-attr    = label('Q) .
  eq metadata-attr = metadata("") .

  --- INP: AttrSet1 AttrSet2
  --- PRE: None
  --- OUT: All Attrs in AttrSet1 that are not in AttrSet2;
  ---      here we ignore subterms; we only match top operator
  eq (special(HL) AS) % (special(HL') AS') = AS % AS' .
  eq (id(T)       AS) % (id(T')       AS') = AS % AS' .
  eq (left-id(T)  AS) % (left-id(T)   AS') = AS % AS' .
  eq (right-id(T) AS) % (right-id(T)  AS') = AS % AS' .
  eq (strat(NL)   AS) % (strat(NL')   AS') = AS % AS' .
  eq (frozen(NL)  AS) % (frozen(NL')  AS') = AS % AS' .
  eq (poly(NL)    AS) % (poly(NL')    AS') = AS % AS' .
  eq (prec(N)     AS) % (prec(N')     AS') = AS % AS' .
  eq (gather(QL)  AS) % (gather(QL')  AS') = AS % AS' .
  eq (format(QL)  AS) % (format(QL')  AS') = AS % AS' .
  eq (print(QL)   AS) % (print(QL')   AS') = AS % AS' .
  eq (label(Q)    AS) % (label(Q')    AS') = AS % AS' .
  eq (metadata(S) AS) % (metadata(S') AS') = AS % AS' .
  eq              AS  %               AS'  = AS - AS' [owise] .

  --- INP: AttrSet1 AttrSet2
  --- PRE: None
  --- OUT: All Attrs in AttrSet1 that are not in AttrSet2
  eq (A AS) - (A AS') = AS - AS' .
  eq    AS  -    AS'  = AS [owise] .


  --- INP: AttrSet1 AttrSet2
  --- PRE: None
  --- OUT: true iff all kinds of Attrs in AttrSet1 are in AttrSet2
  eq in(AS,AS') = (AS % AS') == none .
endfm

fmod OPDECL-EXTRA is
  pr META-LEVEL .
  pr ATTR-EXTRA .
  op qid        : OpDecl -> Qid .
  op argTypes   : OpDecl -> TypeList .
  op resultType : OpDecl -> Type .
  op attrSet    : OpDecl -> AttrSet .
  op metadata   : OpDecl ~> String .
  var Q : Qid    . var T  : Type    . var TL : TypeList .
  var S : String . var AS : AttrSet .
  eq qid(op Q : TL -> T [AS].)        = Q  .
  eq argTypes(op Q : TL -> T [AS].)   = TL .
  eq resultType(op Q : TL -> T [AS].) = T  .
  eq attrSet(op Q : TL -> T [AS].)    = AS .
  eq metadata(op Q : TL -> T [metadata(S) AS].) = S .
endfm

fmod OPDECLSET-EXTRA is
  pr OPDECL-EXTRA .
  pr META-MODULE .
  pr UNIT-FM .
  pr TERM-EXTRA .

  sort OpDeclSetPair .
  op ((_,_)) : OpDeclSet OpDeclSet -> OpDeclSetPair [ctor] .

  op _inODS_     : OpDecl OpDeclSet -> Bool .
  op _-_         : OpDeclSet OpDeclSet -> OpDeclSet .
  op subset?     : OpDeclSet OpDeclSet -> Bool .
  op $opdiff     : OpDeclSet OpDeclSet OpDeclSet -> OpDeclSet .
  op argTypeSet  : OpDeclSet -> TypeListSet .
  op $argTypeSet : OpDeclSet TypeListSet -> TypeListSet .
  op resTypeSet  : OpDeclSet -> TypeSet .
  op $resTypeSet : OpDeclSet TypeSet -> TypeListSet .
  op constants   : OpDeclSet -> OpDeclSet .
  op $constants  : OpDeclSet OpDeclSet -> OpDeclSet .
  op splitConsts  : OpDeclSet -> OpDeclSetPair .
  op $splitConsts : OpDeclSet OpDeclSet OpDeclSet -> OpDeclSetPair .
  op ctors       : OpDeclSet -> OpDeclSet .
  op nonctors    : OpDeclSet -> OpDeclSet .
  op splitCtors  : OpDeclSet -> OpDeclSetPair .
  op stripAttrs  : OpDeclSet -> OpDeclSet .
  op opByName    : Qid OpDeclSet -> OpDeclSet .
  op opByName    : Qid Sort OpDeclSet -> OpDeclSet .
  op opByResType : Type OpDeclSet -> OpDeclSet .
  op uniqueOpTerm : Qid OpDeclSet ~> Term .
  op uniqueOpTerm : Qid Sort OpDeclSet ~> Term .
  ---
  op qid         : OpDeclSet -> QidSet .
  op argTypes    : OpDeclSet -> TypeListSet .
  op resultType  : OpDeclSet -> TypeSet .
  --- op attrSet : OpDeclSet -> AttrSetSet . --- right now no attrsetset sort to use...

  var M : Module .
  var TS : TypeSet .
  var TLS : TypeListSet .
  var OS OS' OS'' : OpDeclSet .
  var OD OD' : OpDecl .
  var Q : Qid .
  var AS : AttrSet .
  var TYL : TypeList .
  var TY : Type .
  var QS : QidSet .
  var S : Sort .
  var U : Module .
  var T : Term .

  --- INP: OpDecl OpDeclSet
  --- PRE: None
  --- OUT: true iff OpDecl is in OpDeclSet
  eq OD inODS OD OS = true .
  eq OD inODS OS = false [owise] .

  --- INP: OpDeclSet1 OpDeclSet2
  --- PRE: None
  --- OUT: Removes all OpDecls in set 2
  ---      from set 1
  eq OS - OS' = $opdiff(OS,OS',none) .
  eq $opdiff(OD OS,OS',OS'') =
    $opdiff(OS,OS',if OD inODS OS' then none else OD fi OS'') .
  eq $opdiff(none,OS',OS'') = OS'' .

  --- INP: OpDeclSet1 OpDeclSet2
  --- PRE: None
  --- OUT: true iff OpDeclSet1 is a subset of OpDeclSet2
  eq subset?(OD OS,OS') = OD inODS OS' and-then subset?(OS,OS') .
  eq subset?(none,OS') = true .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: A set of TypeLists represents the arguments from each OpDecl
  eq argTypeSet(OS) = $argTypeSet(OS,none) .
  eq $argTypeSet(OD OS,TLS) = $argTypeSet(OS,argTypes(OD) ; TLS) .
  eq $argTypeSet(none,TLS) = TLS .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: A TypeSet representing the results from each OpDecl
  eq resTypeSet(OS) = $resTypeSet(OS,none) .
  eq $resTypeSet(OD OS,TS) = $resTypeSet(OS,resultType(OD) ; TS) .
  eq $resTypeSet(none,TS) = TS .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Extracts all constants
  eq constants(OS) = $constants(OS,none) .
  eq $constants(OD OS,OS') =
    $constants(OS,if argTypes(OD) == nil then OD else none fi OS') .
  eq $constants(none,OS') = OS' .

  eq splitConsts(OS) = $splitConsts(OS,none,none) .
  eq $splitConsts(OD OS,OS',OS'') =
    if argTypes(OD) == nil then $splitConsts(OS,OD OS',   OS'')
                           else $splitConsts(OS,   OS',OD OS'') fi .
  eq $splitConsts(none, OS',OS'') = (OS',OS'') .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Extracts all ctors
  op $ctors      : OpDeclSet OpDeclSet -> OpDeclSet .
  eq ctors(OS) = $ctors(OS,none) .
  eq $ctors(op Q : TYL -> TY [ctor AS]. OS,OS') =
     $ctors(OS,op Q : TYL -> TY [ctor AS]. OS') .
  eq $ctors(OS,OS') = OS' [owise] .

  op $nonctors      : OpDeclSet OpDeclSet -> OpDeclSet .
  eq nonctors(OS) = $nonctors(OS,none) .
  eq $nonctors(op Q : TYL -> TY [ctor AS]. OS,OS') =
     $nonctors(OS,op Q : TYL -> TY [ctor AS]. OS') .
  eq $nonctors(OS,OS') = OS [owise] .

  op $splitCtors      : OpDeclSet OpDeclSet -> OpDeclSetPair .
  eq splitCtors(OS) = $splitCtors(OS,none) .
  eq $splitCtors(op Q : TYL -> TY [ctor AS]. OS,OS') =
     $splitCtors(OS,op Q : TYL -> TY [ctor AS]. OS') .
  eq $splitCtors(OS,OS') = (OS',OS) [owise] .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Replaces each op's AttrSet with none
  eq stripAttrs(op Q : TYL -> TY [AS]. OS) =
   op Q : TYL -> TY [none]. stripAttrs(OS) .
  eq stripAttrs(none) = none .

  --- INP: Qid OpDeclSet
  --- PRE: None
  --- OUT: Get ops with given name
  eq opByName(Q,OD OS) = if Q == qid(OD) then OD else none fi opByName(Q,OS) .
  eq opByName(Q,none) = none .

  --- PRE: None
  --- OUT: Get ops with given name and sort name
  eq opByName(Q,S,OD OS) = if Q resultType(OD) == qid(OD) resultType(OD) then OD else none fi opByName(Q,S,OS) .
  eq opByName(Q,S,none) = none .

  --- PRE: None
  --- OUT: Get ops with given res type
  eq opByResType(TY,OD OS) = if resultType(OD) == TY then OD else none fi opByResType(TY,OS) .
  eq opByResType(TY,none) = none .

  --- INP: Qid OpDeclSet
  --- PRE: Qid is a unique op name
  --- OUT: Term built according to operator
 ceq uniqueOpTerm(Q,OS) = buildTerm(opByName(Q,OS),0) if opByName(Q,OS) :: OpDecl .
 ceq uniqueOpTerm(Q,S,OS) = buildTerm(opByName(Q,S,OS),0) if opByName(Q,S,OS) :: OpDecl .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Qid/TypeList/TypeSets (Set functor liftings of OpDecl type)
  eq qid(OD OD' OS)        = qid(OD) ; qid(OD' OS) .
  eq qid(none)              = none .
  eq argTypes(OD OD' OS)   = argTypes(OD) ; argTypes(OD' OS) .
  eq argTypes(none)         = none .
  eq resultType(OD OD' OS) = resultType(OD) ; resultType(OD' OS) .
  eq resultType(none)       = none .

  --- INP: OpDeclSet OpDeclSet
  --- PRE: None
  --- OUT: true iff OpDeclSets intersect?
  op intersect? : OpDeclSet OpDeclSet -> Bool .
  op $intersect? : OpDecl OpDeclSet -> Bool .
  eq intersect?(OD OS,OS') = $intersect?(OD,OS') or-else intersect?(OS,OS') .
  eq intersect?(none,OS') = false .
  eq $intersect?(OD OS,OD OS') = true .
  eq $intersect?(OS,OS') = false [owise] .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: True iff there is an assoc op that isn't comm
  op assocNotComm? : OpDeclSet -> Bool .
  op noComm? : AttrSet -> Bool .
  op assoc? : AttrSet -> Bool .
  op id? : AttrSet -> Bool .
  ceq assocNotComm?(op Q : TYL -> TY [assoc AS]. OS) = true if noComm?(AS) .
  eq assocNotComm?(OS) = false [owise] .
  eq noComm?(comm AS) = false .
  eq noComm?(AS) = true [owise] .
  eq assoc?(assoc AS) = true .
  eq assoc?(AS) = false [owise] .
  eq id?(id(T)       AS) = true .
  eq id?(right-id(T) AS) = true .
  eq id?(left-id(T)  AS) = true .
  eq id?(            AS) = false [owise] .

  op removeComm : OpDeclSet -> OpDeclSet .
  eq removeComm(op Q : TYL -> TY [AS]. OS) =
    if in(comm,AS) and not in(assoc,AS) then
      op Q : TYL -> TY [AS % comm].
    else
      op Q : TYL -> TY [AS].
    fi removeComm(OS) .
  eq removeComm(none) = none .

  op removeIdAttrs : OpDeclSet -> OpDeclSet .
  eq removeIdAttrs(op Q : TYL -> TY [AS]. OS) =
    (op Q : TYL -> TY [AS % (id-attr  right-id-attr  left-id-attr)].)
     removeIdAttrs(OS) .
  eq removeIdAttrs(none) = none .

  --- PRE: None
  --- OUT: Return true if any attr occurs
  op anyAttrOccurs? : AttrSet OpDeclSet -> Bool .
  eq anyAttrOccurs?(AS,OD OS) =
    AS % attrSet(OD) =/= AS or-else anyAttrOccurs?(AS,OS) .
  eq anyAttrOccurs?(AS,none) = false .

  op au-ops? : OpDeclSet -> Bool .
  eq au-ops?(OD OS) =
    (assoc?(attrSet(OD))  and
     noComm?(attrSet(OD)) and
     id?(attrSet(OD))) or-else au-ops?(OS) .
  eq au-ops?(none) = false .

  op id-ops? : OpDeclSet -> Bool .
  eq id-ops?(OS) = anyAttrOccurs?(id-attr right-id-attr left-id-attr,OS) .
endfm

fmod OPDECL-TYPING is
  pr META-LEVEL .
  pr TYPE-EXTRA .
  pr OPDECLSET-EXTRA .

  op opLeq : Module OpDecl OpDecl -> Bool .
  op getMaximal : Module OpDeclSet -> OpDeclSet .
  op $getMaximal : Module OpDeclSet OpDeclSet OpDeclSet -> OpDeclSet .
  op $getMaximal1 : Module OpDecl OpDeclSet -> Bool .
  op opsBelow : Module OpDecl -> OpDeclSet .
  op opsBelow : Module OpDecl OpDeclSet -> OpDeclSet .
  op $opsBelow : Module OpDecl OpDeclSet OpDeclSet -> OpDeclSet .
  op relatedOps : Module Qid TypeList OpDeclSet -> OpDeclSet .
  op relatedOps : Module OpDecl OpDeclSet -> OpDeclSet .

  var M : Module .
  var OD OD' : OpDecl .
  var OS OS' OS'' : OpDeclSet .
  var TYL TYL' : TypeList .
  var TY TY' : Type .
  var AS AS' : AttrSet .
  var NTL : NeTermList .
  var C : Constant .
  var Q : Qid .

  --- INP: Module OpDecl1 OpDecl2
  --- PRE: OpDecls are well-defined with respect to Module
  --- OUT: true iff names agree and argTypes of OpDecl1 are less than that
  ---      of OpDecl2
  eq opLeq(M,OD,OD') =
    qid(OD) == qid(OD') and-then typeLeqS(M,argTypes(OD),argTypes(OD')) .

  --- INP: Module OpDeclSet
  --- PRE: OpDeclSet is well-defined with respect to Module
  --- OUT: The maximal OpDecls in the OpDeclSet
  eq getMaximal(M,OS) = $getMaximal(M,OS,none,none) .
  eq $getMaximal(M,OD OS,OS',OS'') =
    if $getMaximal1(M,OD,OS OS') then
      $getMaximal(M,OS,OD OS',OD OS'')
    else
      $getMaximal(M,OS,OS',OS'')
    fi .
  eq $getMaximal(M,none,OS',OS'') = OS'' .
  eq $getMaximal1(M,OD,OD' OS) =
    not opLeq(M,OD,OD') and-then $getMaximal1(M,OD,OS) .
  eq $getMaximal1(M,OD,none) = true .

  --- INP: Module OpDecl [OpDeclSet]
  --- PRE: OpDecls are well-defined with respect to Module
  --- OUT: All OpDecls in OpDeclSet that are less than OpDecl
  eq opsBelow(M,OD) = opsBelow(M,OD,getOps(M)) .
  eq opsBelow(M,OD,OS) = $opsBelow(M,OD,OS,none) .
  eq $opsBelow(M,OD,OD' OS',OS) =
    if opLeq(M,OD',OD) and OD' =/= OD then
      $opsBelow(M,OD,OS',OD' OS)
    else
      $opsBelow(M,OD,OS',OS)
    fi .
  eq $opsBelow(M,OD,none,OS) = OS .

  --- INP: Module OpDecl/(Qid TypeList) OpDeclSet
  --- PRE: OpDecls are well-defined with respect to Module
  --- OUT: Set of OpDecls in OpDeclSet that are related to OpDecl; that is
  ---      their arguments are in the same kind
  eq relatedOps(M,Q,TYL,OS) =
    relatedOps(M,op Q : TYL -> 'Sort [none].,OS) .
  eq relatedOps(M,OD,OD' OS) =
    if qid(OD) == qid(OD') and typeRelS(M,argTypes(OD),argTypes(OD')) then
      OD' relatedOps(M,OD,OS)
    else
      relatedOps(M,OD,OS)
    fi .
  eq relatedOps(M,OD,none) = none .

  --- INP: Module TypeList OpDeclSet
  --- PRE: OpDecls are well-defined with respect to Module
  --- OUT: All OpDecls in OpDeclSet that are less than OpDecl
  op opsAbove : Module TypeList -> OpDeclSet .
  op opsAbove : Module TypeList OpDeclSet -> OpDeclSet .
  op $opsAbove : Module TypeList OpDeclSet OpDeclSet -> OpDeclSet .
  eq opsAbove(M,TYL) = opsAbove(M,TYL,getOps(M)) .
  eq opsAbove(M,TYL,OS) = $opsAbove(M,TYL,OS,none) .
  eq $opsAbove(M,TYL,OD' OS',OS'') =
    if typeLeqS(M,TYL,argTypes(OD')) then
      $opsAbove(M,TYL,OS',OS'' OD')
    else
      $opsAbove(M,TYL,OS',OS'')
    fi .
  eq $opsAbove(M,TYL,none,OS'') = OS'' .

  --- INP: Module OpDeclSet
  --- PRE: OpDeclSet is well-defined with respect to Module
  --- OUT: The minimal OpDecls in the OpDeclSet
  op getMinimal : Module OpDeclSet -> OpDeclSet .
  op $getMinimal : Module OpDeclSet OpDeclSet OpDeclSet -> OpDeclSet .
  op $getMinimal1 : Module OpDecl OpDeclSet -> Bool .
  eq getMinimal(M,OS) = $getMinimal(M,OS,none,none) .

  --- OS'' are the mininmal
  eq $getMinimal(M,OD OS,OS',OS'') =
    --- if minimal w/respect to rest of OS, add to minimal and non-minimal pools
    if $getMinimal1(M,OD,OS OS') then
      $getMinimal(M,OS,OD OS',OD OS'')
    else
      $getMinimal(M,OS,OS',OS'')
    fi .
  eq $getMinimal(M,none,OS',OS'') = OS'' .

  --- Check if OD is minimal
  eq $getMinimal1(M,OD,OD' OS) =
    not typeLeqS(M,resultType(OD'),resultType(OD)) and-then $getMinimal1(M,OD,OS) .
  eq $getMinimal1(M,OD,none) = true .

  --- PRE: TypeList and Type are defined in Module
  --- OUT: Given a term with structure Q(X1...XN) whose
  ---      least sort is Type where the sorts of X1...XN
  ---      correspond to the Types in TypeList, find all
  ---      possible operators in the OpDeclSet that
  ---      could be instantiated to get this term
  op findOps : Module OpDeclSet Qid TypeList Type -> OpDeclSet .
  eq findOps(M,OD OS,Q,TYL,TY) =
    if typeLeqS(M,TYL,argTypes(OD)) and qid(OD) == Q and
        typeLeqS(M,resultType(OD),TY) then
      OD
    else
      none
    fi findOps(M,OS,Q,TYL,TY) .
  eq findOps(M,none,Q,TYL,TY) = none .

  --- PRE: Term and OpDeclSet are well-defined in Module
  --- OUT: Set of OpDecls that could top this term
  op findOps : Module OpDeclSet Term -> OpDeclSet .
  eq findOps(M,OS,Q[NTL]) = findOps(M,OS,Q,termListTypes(M,NTL),leastSort(M,Q[NTL])) .
  eq findOps(M,OS,C) = findOps(M,OS,getName(C),nil,leastSort(M,C)) .

  --- PRE: None
  --- OUT: True iff no operators share the same name in OpDeclSet
  op overloaded? : OpDeclSet -> Bool .
  eq overloaded?(op Q : TYL -> TY [AS]. op Q : TYL' -> TY' [AS']. OS) = true .
  eq overloaded?(OS)                                                  = false [owise] .
endfm

fmod STMT-EXTRA is
  pr META-LEVEL .
  pr TERM-EXTRA .
  pr UNIT-FM .
  pr TERMSET-FM .

  var M : Module . var R R' : Rule . var RS : RuleSet . var Q : Qid . var Y : Sort .
  var U V T : Term . var A : AttrSet . var C : Condition . var EC : EqCondition .
  var E E' : Equation . var ES ES' : EquationSet . var B B' : MembAx . var BS : MembAxSet .
  var S : String .

  op rl-labels : Module -> [QidSet] .
  op rl-labels : RuleSet -> [QidSet] .
  eq rl-labels(M) = rl-labels(getRls(M)) .
  eq rl-labels(R R' RS) = rl-labels(R) ; rl-labels(R' RS) .
  eq rl-labels(rl U => V [label(Q) A].) = Q .
  eq rl-labels(crl U => V if C [label(Q) A].) = Q .
  eq rl-labels(none) = none .

  op eq-labels   : Module -> [QidSet] .
  op eq-labels   : EquationSet -> [QidSet] .
  eq eq-labels(M) = eq-labels(getEqs(M)) .
  eq eq-labels(E E' ES) = eq-labels(E) ; eq-labels(E' ES) .
  eq eq-labels(eq U = V [label(Q) A].) = Q .
  eq eq-labels(ceq U = V if EC [label(Q) A].) = Q .
  eq eq-labels(none) = none .

  op mb-labels : Module -> [QidSet] .
  op mb-labels : MembAxSet -> [QidSet] .
  eq mb-labels(M) = mb-labels(getMbs(M)) .
  eq mb-labels(B B' BS) = mb-labels(B) ; mb-labels(B' BS) .
  eq mb-labels(mb U : Y [label(Q) A].) = Q .
  eq mb-labels(cmb U : Y if EC [label(Q) A].) = Q .
  eq mb-labels(none) = none .

  op stmt-labels : Module -> [QidSet] .
  eq stmt-labels(M) = rl-labels(M) ; eq-labels(M) ; mb-labels(M) .

  op metadata : Rule ~> String .
  op metadata : Equation ~> String .
  op metadata : MembAx ~> String .
  eq metadata(eq U = V [metadata(S) A].) = S .
  eq metadata(ceq U = V if EC [metadata(S) A].) = S .
  eq metadata(rl U => V [metadata(S) A].) = S .
  eq metadata(crl U => V if C [metadata(S) A].) = S .
  eq metadata(mb U : Y [metadata(S) A].) = S .
  eq metadata(cmb U : Y if EC [metadata(S) A].) = S .

  op _-_ : EquationSet EquationSet -> EquationSet .
  eq (E ES) - (E ES') = ES - (E ES') .
  eq ES - ES'         = ES [owise] .

  op vars : RuleSet -> QidSet .
  eq vars(rl U => V [A]. RS) = vars(U) ; vars(V) ; vars(RS) .
  eq vars(crl U => V if C [A]. RS) = vars(U) ; vars(V) ; vars(C) ; vars(RS) .
  eq vars((none).RuleSet) = (none).QidSet .

  op vars : EquationSet -> QidSet .
  eq vars(eq U = V [A]. ES) = vars(U) ; vars(V) ; vars(ES) .
  eq vars(ceq U = V if EC [A]. ES) = vars(U) ; vars(V) ; vars(EC) ; vars(ES) .
  eq vars((none).EquationSet) = (none).QidSet .

  op vars : MembAxSet -> QidSet .
  eq vars(mb U : Y [A]. BS) = vars(U) ; vars(BS) .
  eq vars(cmb U : Y if EC [A]. BS) = vars(U) ; vars(EC) ; vars(BS) .
  eq vars((none).MembAxSet) = (none).QidSet .

  op vars : Condition -> QidSet .
  eq vars(U = V  /\ C) = vars(U) ; vars(V) ; vars(C) .
  eq vars(U := V /\ C) = vars(U) ; vars(V) ; vars(C) .
  eq vars(U : Y  /\ C) = vars(U) ; vars(C) .
  eq vars(U => V /\ C) = vars(U) ; vars(V) ; vars(C) .
  eq vars((nil).EqCondition) = (none).QidSet .

  op lhs : Rule -> Term .
  op lhs : Equation -> Term .
  op lhs : RuleSet -> TermSet .
  op lhs : EquationSet -> TermSet .
  eq lhs( rl U => V       [A].) = U .
  eq lhs(crl U => V if C  [A].) = U .
  eq lhs( eq U =  V       [A].) = U .
  eq lhs(ceq U =  V if EC [A].) = U .
  eq lhs(R R' RS) = lhs(R) | lhs(R' RS) .
  eq lhs((none).RuleSet) = none .
  eq lhs(E E' ES) = lhs(E) | lhs(E' ES) .
  eq lhs((none).EquationSet) = none .

  op set-lhs : Rule Term -> Rule .
  op set-lhs : Equation Term -> Equation .
  eq set-lhs(rl  U => V       [A].,T) =  rl T => V       [A]. .
  eq set-lhs(eq  U =  V       [A].,T) =  eq T =  V       [A]. .
  eq set-lhs(crl U => V if C  [A].,T) = crl T => V if C  [A]. .
  eq set-lhs(ceq U =  V if EC [A].,T) = ceq T =  V if EC [A]. .

  op rhs : Rule -> Term .
  op rhs : Equation -> Term .
  op rhs : RuleSet -> TermSet .
  op rhs : EquationSet -> TermSet .
  eq rhs( rl U => V       [A].) = V .
  eq rhs(crl U => V if C  [A].) = V .
  eq rhs( eq U =  V       [A].) = V .
  eq rhs(ceq U =  V if EC [A].) = V .
  eq rhs(R R' RS) = rhs(R) | rhs(R' RS) .
  eq rhs((none).RuleSet) = none .
  eq rhs(E E' ES) = rhs(E) | rhs(E' ES) .
  eq rhs((none).EquationSet) = none .

  op cond : Rule -> Condition .
  op cond : Equation -> EqCondition .
  eq cond( rl U => V       [A].) = nil .
  eq cond(crl U => V if C  [A].) = C   .
  eq cond( eq U =  V       [A].) = nil .
  eq cond(ceq U =  V if EC [A].) = EC  .

  op attrSet : Rule -> AttrSet .
  op attrSet : Equation -> AttrSet .
  eq attrSet( rl U => V       [A].) = A .
  eq attrSet(crl U => V if C  [A].) = A .
  eq attrSet( eq U =  V       [A].) = A .
  eq attrSet(ceq U =  V if EC [A].) = A .

  op lhsIsVar? : Rule -> Bool .
  op lhsIsVar? : Equation -> Bool .
  eq lhsIsVar?( rl U => V       [A].) = U :: Variable .
  eq lhsIsVar?(crl U => V if C  [A].) = U :: Variable .
  eq lhsIsVar?( eq U =  V       [A].) = U :: Variable .
  eq lhsIsVar?(ceq U =  V if EC [A].) = U :: Variable .

  op anyLhsIsVar? : RuleSet -> Bool .
  op anyLhsIsVar? : EquationSet -> Bool .
  eq anyLhsIsVar?(R RS) = lhsIsVar?(R) or-else anyLhsIsVar?(RS) .
  eq anyLhsIsVar?((none).RuleSet) = false .
  eq anyLhsIsVar?(E ES) = lhsIsVar?(E) or-else anyLhsIsVar?(ES) .
  eq anyLhsIsVar?((none).EquationSet) = false .

  op eqsByMetadata : String EquationSet -> EquationSet .
  eq eqsByMetadata(S,E ES) = if metadata(E) == S then E else none fi eqsByMetadata(S,ES) .
  eq eqsByMetadata(S,none) = none .

  op eqCondToEqs : EqCondition ~> EquationSet .
  eq eqCondToEqs(U = V /\ EC) = eq U = V [none]. eqCondToEqs(EC) .
  eq eqCondToEqs(nil)         = none .
endfm

fmod INTERREDUCE is
  pr STMT-EXTRA .

  var U : Module .
  var Eq : Equation .
  var AS : AttrSet .
  var Eqs RedEqs : EquationSet .

  op interreduce : Module EquationSet -> EquationSet .
  op interreduce : Module EquationSet EquationSet -> EquationSet .
  eq interreduce(U,Eqs) = interreduce(U,Eqs,none) .
  eq interreduce(U,Eq Eqs,RedEqs) =
    interreduce(U,Eqs,RedEqs
      orientHack(deleteTrivial(eq metaReduce2(addEqs(Eqs RedEqs,U),lhs(Eq)) =
         metaReduce2(addEqs(Eqs RedEqs,U),rhs(Eq)) [none].))) .
  eq interreduce(U,none,RedEqs) = RedEqs .

  op deleteTrivial : Equation -> EquationSet .
  eq deleteTrivial(Eq) = if lhs(Eq) == rhs(Eq) then none else Eq fi .

  op orientHack : EquationSet -> EquationSet .
  eq orientHack(eq 'false.Bool = 'true.Bool [AS].) = eq 'true.Bool = 'false.Bool [AS]. .
  eq orientHack(Eq)                                = Eq [owise] .
  eq orientHack(none) = none .
endfm

--- this module has functionality to generate unique prefixes with
--- respect to the sorts/operators in a module; this is useful when
--- an algorithm needs to generate fresh sorts/operators; if the
--- generated sort/operator will be needed often, it can be memoized
fmod UNIQUE-PREFIX is
  pr META-LEVEL .
  pr OPDECLSET-EXTRA .
  pr STMT-EXTRA .
  pr SET{String} .

  op sortPrefix     : Module             -> String [memo] .
  op sortPrefix     : SortSet            -> String .
  op opPrefix       : Module             -> String [memo] .
  op opPrefix       : OpDeclSet          -> String .
  op lblPrefix      : Module             -> String .
  op uniquePrefix   : QidSet             -> String .
  op uniquePrefix   : String Set{String} -> String .
  op qidSetToStrSet : QidSet             -> Set{String} .
  op uniqPrefixChar :                    -> Char .

  var P S : String . var SS : Set{String} . var D : Qid . var Q : QidSet .

  eq uniqPrefixChar = "@" .

  eq sortPrefix(M:Module)   = uniquePrefix(getSorts(M:Module)) .
  eq sortPrefix(S:SortSet)  = uniquePrefix(S:SortSet) .
  eq opPrefix(M:Module)     = uniquePrefix(qid(getOps(M:Module))) .
  eq opPrefix(O:OpDeclSet)  = uniquePrefix(qid(O:OpDeclSet)) .
  eq lblPrefix(M:Module)    = uniquePrefix(stmt-labels(M:Module)) .
  eq uniquePrefix(Q)        = uniquePrefix("@",qidSetToStrSet(Q)) .
  eq uniquePrefix(P,(S,SS)) = if P == substr(S,0,length(P)) then uniquePrefix(P + uniqPrefixChar,(S,SS))
                                                         else uniquePrefix(P,SS) fi .
  eq uniquePrefix(P,empty)  = P .
  eq qidSetToStrSet(D ; Q)  = string(D) , qidSetToStrSet(Q) .
  eq qidSetToStrSet(none)   = empty .

endfm

--- Module checks if all the rules in the module we are analyzing in the same kind.
--- If not, that means module cannot be topmost
--- TODO: implement full topmost check
fmod RULES-SHARE-KIND is
  pr META-LEVEL .

  op rules-share-kind : Module -> Bool .
  op rules-share-kind : Module RuleSet -> Bool .
  op rules-share-kind : Module Type RuleSet -> Bool .
  op getRuleType     : Module ~> Type .
  op getRuleType     : Module RuleSet ~> Type .

  var M : Module . var L R : Term . var Y : Type .
  var RLS : RuleSet . var AS : AttrSet .

  eq rules-share-kind(M) = rules-share-kind(M,getRls(M)) .
  eq rules-share-kind(M,none) = false .
  eq rules-share-kind(M,rl L => R [AS] . RLS) =
    leastSort(M,L) ; leastSort(M,R) :: NeSortSet and-then sameKind(M,leastSort(M,L),leastSort(M,R)) and-then rules-share-kind(M,leastSort(M,L),RLS) .
  eq rules-share-kind(M,crl L => R if C:Condition [AS] . RLS) =
    leastSort(M,L) ; leastSort(M,R) :: NeSortSet and-then sameKind(M,leastSort(M,L),leastSort(M,R)) and-then rules-share-kind(M,leastSort(M,L),RLS) .
  eq rules-share-kind(M,Y,none) = true .
  eq rules-share-kind(M,Y,rl L => R [AS] . RLS) =
    leastSort(M,L) ; leastSort(M,R) :: NeSortSet and-then sameKind(M,Y,leastSort(M,L)) and-then sameKind(M,Y,leastSort(M,R)) and-then rules-share-kind(M,Y,RLS) .
  eq rules-share-kind(M,Y,crl L => R if C:Condition [AS] . RLS) =
    leastSort(M,L) ; leastSort(M,R) :: NeSortSet and-then sameKind(M,Y,leastSort(M,L)) and-then sameKind(M,Y,leastSort(M,R)) and-then rules-share-kind(M,Y,RLS) .

  eq getRuleType(M) = getRuleType(M,getRls(M)) .
  eq getRuleType(M,rl L => R [AS] . RLS) = leastSort(M,L) .
  eq getRuleType(M,crl L => R if C:Condition [AS] . RLS) = leastSort(M,L) .
endfm

fmod MOD-EXTRA is
  pr UNIT-FM .
  op protecting? : ModuleExpression ImportList -> Bool .
  op setRls      : Module QidList -> [Module] .
  op setRls      : QidList RuleSet RuleSet -> [RuleSet] .
  op getModQid   : Import -> Qid .
  op getImports2 : Module -> [ImportList] .
  op getImports2 : Module Qid -> [ImportList] .
  op getImports2 : ImportList ImportList -> [ImportList] .
  op getImports2 : Module ImportList ImportList -> [ImportList] .

  var ME ME' : ModuleExpression . var M M' : Module . var I : Import .
  var Q : Qid . var QK : [Qid] . var QL : QidList . var L R : Term . var A : AttrSet .
  var RL : Rule . var RS RS' : RuleSet . var C : Condition .
  var IL IL1 IL2 : ImportList .

  --- INP: ModuleExpression ImportList
  --- PRE: None
  --- OUT: true iff ModuleExpression is protected in ImportList
  eq protecting?(ME,protecting ME' . IL) = ME == ME' or-else protecting?(ME,IL) .
  eq protecting?(ME,I IL) = protecting?(ME,IL) [owise] .
  eq protecting?(ME,nil) = false .

  --- INP: Module QidList
  --- PRE: Each Qid in QidList refers to a rule label in Module
  --- OUT: Set of rules which are labelled with any Qid in QidList
  eq setRls(M,QL) = setRls(M,setRls(QL,getRls(M),none)) .
  eq setRls(Q QL,rl L => R [label(Q) A]. RS,RS') = setRls(Q QL,RS,rl L => R [label(Q) A]. RS') .
  eq setRls(Q QL,crl L => R if C [label(Q) A]. RS,RS') = setRls(Q QL,RS,crl L => R if C [label(Q) A]. RS') .
  eq setRls(Q QL,RS,RL RS') = setRls(QL,RS,none) RL RS' [owise] .
  eq setRls(nil,RS,none) = none .

  --- INP: Module/Qid (name of Module)
  --- PRE: Module (and all of its recursive imports) have names that are Qids
  --- OUT: ImportList that contains imports of this module and its dependencies
  eq getImports2(M) = getImports2(M,getName(M)) .
  eq getImports2(M,Q) = getImports2(getImports(upModule(Q,false)),nil) .
  eq getImports2(M,QK) = getImports(M) . --- fallback case
  eq getImports2(I IL,IL1 I IL2) = getImports2(IL,IL1 I IL2) .
  eq getImports2(nil,IL2) = IL2 .
  eq getImports2(I IL,IL2) = getImports2(upModule(getModQid(I),false),IL,IL2 I) [owise] .
  eq getImports2(M,IL,IL2) = getImports2(getImports(M) IL,IL2)  .

  --- INP: Import
  --- PRE: ModuleExpression in Import is a Qid
  --- OUT: Qid that corresponds to the Module name in this Import
  eq getModQid(protecting Q .) = Q .
  eq getModQid(including Q .) = Q .
  eq getModQid(extending Q .) = Q .
endfm

view Module from TRIV to META-MODULE is sort Elt to Module . endv

fmod MODULE-LIST is
  pr LIST{Module} * (op nil : -> List{Module} to nilmod, op __ : List{Module} List{Module} -> List{Module} to _;_, sort List{Module} to ModuleList, sort NeList{Module} to NeModuleList) .
endfm

fmod SCOPED-MAP is
  pr MODULE-LIST .
  sort ScopedMap .
  op ((_,_,_)) : Module Qid ModuleList -> ScopedMap [ctor] .
endfm

view ScopedMap from TRIV to SCOPED-MAP is sort Elt to ScopedMap . endv

fmod SCOPED-MAPLIST is
  pr LIST{ScopedMap} * (sort List{ScopedMap} to ScopedMapList) .
endfm

view ScopedMapList from TRIV to SCOPED-MAPLIST is sort Elt to ScopedMapList . endv
view QidList from TRIV to QID-LIST is sort Elt to QidList . endv

fmod SCOPED-REGISTRY is
  pr MODULE-LIST .
  pr MAP-EXTRA{Qid,ScopedMapList} * (sort Map{Qid,ScopedMapList} to ScopedRegistry,
                                     sort Entry{Qid,ScopedMapList} to ScopedRegistryEntry) .
  pr UNIT-FM .
  pr MOD-EXTRA .

  var Task Impl : Qid .
  var ImplMod Mod : Module .
  var ImplList ImplList' : ScopedMapList .
  var Registry Registry' : ScopedRegistry .
  var ImplModList ModArgList : ModuleList .
  var IL : ImportList .

  op getbackend : Qid Qid ScopedRegistry -> Module .
  eq getbackend(Task,Impl,(Task |-> (ImplList (ImplMod,Impl,ModArgList) ImplList'),Registry)) = ImplMod .
  eq getbackend(Task,Impl,Registry) = noModule [owise] .

  op getModByImpl : Qid ScopedRegistry -> Module .
  eq getModByImpl(Impl,(Task |-> ImplList (ImplMod,Impl,ModArgList) ImplList',Registry)) = ImplMod .
  eq getModByImpl(Impl,Registry) = noModule [owise] .

  --- ### NEW
  op getmodules : ScopedRegistry -> ModuleList .
  op getmodules : ScopedMapList -> ModuleList .
  eq getmodules((Task |-> ImplList, Registry)) = getmodules(ImplList) ; getmodules(Registry) .
  eq getmodules(empty) = nilmod .
  eq getmodules((ImplMod,Impl,ModArgList) ImplList) = ImplMod ; getmodules(ImplList) .
  eq getmodules(nil) = nilmod .

  --- ### NEW
  op protecting? : ModuleList Module -> Bool .
  op protecting? : ModuleList ImportList -> Bool .
  eq protecting?(ImplModList,Mod) = protecting?(ImplModList,getImports2(Mod)) .
  eq protecting?(ImplMod ; ImplModList,IL) =
    protecting?(getName(ImplMod),IL) and-then protecting?(ImplModList,IL) .
  eq protecting?(nilmod,IL) = true .

  --- ### New
  op _*_ : ScopedRegistry ScopedRegistry -> ScopedRegistry .
  eq (Task |-> ImplList, Registry) * (Task |-> ImplList', Registry') =
     (Task |-> ImplList ImplList', Registry) * Registry' .
  eq Registry * Registry' = Registry, Registry' [owise] .
endfm

--- here we give an implementation of an arbitrary fixpoint
--- NOTE: the functional theory here is far too weak, since
---       arbitrary functions don't have fixpoints---but
---       adding the constraints to express that F truly has
---       fixpoints is more work than I want to do right now.
fth FUN is inc TRIV .
  op F : Elt -> Elt .
endfth

fmod FIXF{X :: FUN} is
  pr TRUTH .
  var A A' : X$Elt .
  op FixF : X$Elt -> X$Elt .
  op FixF : X$Elt X$Elt -> X$Elt .
  eq FixF(A) = FixF(A,F(A)) .
  eq FixF(A,A') = if A == A' then A' else FixF(A') fi .
endfm

fmod UNIFICATION-PROBLEM-AUX is
  pr META-LEVEL .

  var UP : UnificationProblem .
  var T T' : Term .

  op UnifProbLHSToTL : UnificationProblem -> NeTermList .
  eq UnifProbLHSToTL(T =? T' /\ UP) = T, UnifProbLHSToTL(UP) .
  eq UnifProbLHSToTL(T =? T') = T .
endfm

---
--- # Meta-Level Functors
---

--- Refine and extend the built-in meta-level renaming operators
fmod META-LEVEL-RENAMING-EXT is
  pr META-LEVEL .
  pr QIDSET-REFINEMENT .
  pr TYPE-EXTRA .

  var R  : Renaming    .
  var RS : RenamingSet .
  var S  : Sort .
  var Q  : Qid .
  var TL : TypeList .
  var T  : Type .
  var A  : AttrSet .

  sort EmptyRenamingSet .

  sort SortRenaming SortRenamingSet .
  sort   OpRenaming   OpRenamingSet .

  subsort SortRenaming < SortRenamingSet .
  subsort   OpRenaming <   OpRenamingSet .

  subsort SortRenaming    OpRenaming    < Renaming    .
  subsort SortRenamingSet OpRenamingSet < RenamingSet .

  subsort EmptyRenamingSet < SortRenamingSet OpRenamingSet < RenamingSet .

  op none : -> EmptyRenamingSet [ctor] .

  op _,_ : EmptyRenamingSet EmptyRenamingSet -> EmptyRenamingSet [ctor ditto] .
  op _,_ :  SortRenamingSet  SortRenamingSet ->  SortRenamingSet [ctor ditto] .
  op _,_ :    OpRenamingSet    OpRenamingSet ->    OpRenamingSet [ctor ditto] .

  op sort_to_       : Sort Sort                     -> SortRenaming [ctor ditto] .
  op op_to_[_]      : Qid Qid AttrSet               ->   OpRenaming [ctor ditto] .
  op op_:_->_to_[_] : Qid TypeList Type Qid AttrSet ->   OpRenaming [ctor ditto] .
  op label_to_      : Qid Qid                       ->   OpRenaming [ctor ditto] .

  eq R  , R    = R  .
  eq RS , none = RS .

  op removeId : RenamingSet -> RenamingSet .
  eq removeId(sort S         to S,     RS) = removeId(RS) .
  eq removeId(label Q        to Q,     RS) = removeId(RS) .
  eq removeId(                         RS) = RS [owise]   .
  --- NB: technically, these might change the attributes
  --- eq removeId(op Q           to Q [A], RS) = removeId(RS) .
  --- eq removeId(op Q : TL -> T to Q [A], RS) = removeId(RS) .
endfm

--- For renaming purposes, whether we are renaming a term, a piece of a module, or a entire module,
--- we always want the ENTIRE flattened module that the term, piece, or module lives in as context.
--- In the code below, I use the variable FM to represent "Flattened Module" and M for "Module."
fmod MODULE-RENAMING is
  pr META-LEVEL-RENAMING-EXT .

  var FM : Module .
  var S S1 S2 : Sort .
  var SDS : SubsortDeclSet .
  var K  : Kind .
  var T T1 T2 : Type .
  var TL TL1 TL2 : TypeList .
  var TS : TypeSet .
  var SRS : SortRenamingSet .
  var ORS : OpRenamingSet .
  var Q Q1 Q2 : Qid .
  var A : AttrSet .
  var ODS : OpDeclSet .

  --- Rename sorts/kinds
  ----------------------
  op rename : Module SortRenamingSet TypeList -> TypeList .
  op rename : Module SortRenamingSet TypeSet  -> TypeSet .
  op rename : Module SortRenamingSet Type     -> Type .
  op rename : Module SortRenamingSet Kind     -> Kind .
  op rename : Module SortRenamingSet Sort     -> Sort .
  op rename :        SortRenamingSet Sort     -> Sort .

  eq rename(FM,SRS,T TL) = rename(FM,SRS,T) rename(SRS,TL) .
  eq rename(FM,SRS,nil)  = nil .

  eq rename(FM,SRS,T ; T1 ; TS) = rename(FM,SRS,T) ; rename(SRS,T1 ; TS) .
  eq rename(FM,SRS,none)   = none .

  eq rename(FM,SRS,K) = qid("[" + string(rename(SRS,pickAny(maximalSorts(FM,K)))) + "]") .
  eq rename(FM,SRS,S) = rename(SRS,S) .

  eq rename((sort S1 to S2, SRS),S) = if S == S1 then S2 else rename(SRS,S) fi .
  eq rename((sort S1 to S2),     S) = if S == S1 then S2 else S fi .
  eq rename( none,               S) = S .

  --- Rename SubsortDeclSets
  --------------------------
  op rename : SortRenamingSet SubsortDeclSet -> SubsortDeclSet .
  eq rename(SRS,subsort S1 < S2 . SDS) =
    (subsort rename(SRS,S1) < rename(SRS,S2) .)
     rename(SRS,SDS) .
  eq rename(SRS,(none).SubsortDeclSet) = none .

  --- Rename OpDeclSets
  ---------------------
  op rename : Module SortRenamingSet OpRenamingSet OpDeclSet -> OpDeclSet .
  eq rename(FM,SRS,ORS,(op Q : TL -> T [A]. ODS)) =
    if $renOp(FM,ORS,Q,TL,T) =/= none
      then (op $renOpId($renOp(FM,ORS,Q,TL,T),Q) : rename(FM,SRS,TL) -> rename(FM,SRS,T) [rename(FM,SRS,ORS,A)].)
      else op Q : TL -> T [A].
    fi rename(FM,SRS,ORS,ODS) .
  eq rename(FM,SRS,ORS,(none).OpDeclSet) = none .

  --- Rename AttrSets
  -------------------
  op rename : Module SortRenamingSet OpRenamingSet AttrSet -> AttrSet .

  --- Auxiliary operators - rename operator ids - assumes complete kind names
  ---------------------------------------------------------------------------
  op $renOpId : OpRenaming Qid ~> Qid .
  eq $renOpId((op Q           to Q2 [A]),Q) = Q2 .
  eq $renOpId((op Q : TL -> T to Q2 [A]),Q) = Q2 .

  op $renOp : Module OpRenamingSet Qid TypeList Type -> OpRenamingSet .
  eq $renOp(FM,ORS,Q,TL,T) = $renOp(ORS,Q,$renKind(FM,TL),$renKind(FM,T)) .

  op $renOp : OpRenamingSet Qid TypeList Type -> OpRenamingSet .
  eq $renOp((op Q1             to Q2 [A], ORS),Q,TL,T) = if Q      == Q1        then (op Q1             to Q2 [A]) else $renOp(ORS,Q,TL,T) fi .
  eq $renOp((op Q1 : TL1 -> T1 to Q2 [A], ORS),Q,TL,T) = if Q T TL == Q1 T1 TL1 then (op Q1 : TL1 -> T1 to Q2 [A]) else $renOp(ORS,Q,TL,T) fi .
  eq $renOp((op Q1             to Q2 [A]),     Q,TL,T) = if Q      == Q1        then (op Q1             to Q2 [A]) else none fi .
  eq $renOp((op Q1 : TL1 -> T1 to Q2 [A]),     Q,TL,T) = if Q T TL == Q1 T1 TL1 then (op Q1 : TL1 -> T1 to Q2 [A]) else none fi .
  eq $renOp((label Q1 to Q2,              ORS),Q,TL,T) = $renOp(ORS,Q,TL,T) .
  eq $renOp((label Q1 to Q2),                  Q,TL,T) = none .

  op $renKind : Module TypeList -> TypeList .
  eq $renKind(FM,T T1 TL1) = $renKind(FM,T) $renKind(FM,T1 TL1) .
  eq $renKind(FM,nil)      = nil .
  eq $renKind(FM,S)        = S .
  eq $renKind(FM,K)        = getKind(FM,K) .
endfm

fmod CTOR-SIG is
  pr UNIT-FM .
  pr OPDECLSET-EXTRA .
  op ctor-sig : Module -> Module [memo] .
  var M : Module .
  eq ctor-sig(M) =
    setRls(setEqs(setMbs(setOps(M,ctors(getOps(M))),none),none),none) .
endfm

fmod HIJACK-BUILTINS is
  pr META-LEVEL .
  pr ATTR-EXTRA .
  pr TYPE-EXTRA .

  var M : Module .
  var Q : Qid .
  var AS : AttrSet .
  var TL : TypeList .
  var T : Type .
  var OS : OpDeclSet .
  var TQ FQ : Qid .
  var TS FS : Sort .

  op hijackQid : Module ~> Type .
  eq hijackQid(M) = hijackQid(getOps(M)) .

  op hijackQid : OpDeclSet ~> Type .
  eq hijackQid(op Q : TL -> T [AS]. OS) = if hijackQid?(AS)
                                            then T
                                            else hijackQid(OS)
                                          fi .

  op hijackQid? : AttrSet -> Bool .
  eq hijackQid?(special(id-hook('QuotedIdentifierSymbol, nil)) AS) = true .
  eq hijackQid?(AS) = false [owise] .

  --- PRE: Module is well-formed
  --- OUT: A QidList of three elements
  ---      1. the Bool sort (if we can find a unique such sort)
  ---      2. the true operator in this module
  ---      3. the false operator in this module
  op hijackBool? : Module ~> QidList .
  eq hijackBool?(M) = hijackBool?(M,getOps(M)) .

  op hijackBool? : Module OpDeclSet ~> QidList .
  eq hijackBool?(M,op TQ : nil -> TS [special(id-hook('SystemTrue,  nil)) AS].
                   op FQ : nil -> FS [special(id-hook('SystemFalse, nil)) AS].
                   OS) = if TS =/= FS then lubSort(M,TS ; FS) else TS fi TQ FQ .
endfm

fmod HETEROGENEOUS-LIST-FUNCTOR is
  pr META-LEVEL .
  pr UNIT-FM .
  pr UNIQUE-PREFIX . --- for opPrefix/sortPrefix
  pr TYPE-EXTRA . --- for maximalSortAbove

  var M : Module .
  var S : Sort . var SS : SortSet .
  var T : Term . var NTL : NeTermList . var TL : TermList .
  var Q : Qid .

  --- Define Free Heterogeneous List Functor over the Module
  op hl-inj : Module Sort -> Qid .
  eq hl-inj(M,S) = qid(opPrefix(M) + "S") .

  op hl-injops : Module SortSet -> OpDeclSet .
  eq hl-injops(M,S ; SS) = (op hl-inj(M,S) : S -> hl-sort(M) [ctor].) hl-injops(M,SS) .
  eq hl-injops(M,none) = none .

  --- NOTE: Op Prefix Not Needed Since Sorts All Fresh
  op hl-listop  : Module -> OpDecl .
  eq hl-listop(M) = (op 'singleton : hl-sort(M) -> hl-sort(M) [ctor].
                     op '_|_ : hl-sort(M) hl-sort(M) -> hl-sort(M) [assoc ctor].) .

  op hl-sort : Module -> Sort .
  eq hl-sort(M) = qid(sortPrefix(M) + "HeterogeneousList") .

  op hl-func : Module -> Module [memo] .
  eq hl-func(M) = addSorts(hl-sort(M),addOps(hl-listop(M) hl-injops(M,getMaximalSorts(M)),M)) .

  --- Define Free Heterogenous List Fuctor over Terms in the Module
  op toHL : Module NeTermList -> Term .
  op $toHL : Module TermList -> TermList .
  eq toHL(M,T) = 'singleton[hl-inj(M,maximalSortAbove(M,leastSort(M,T)))[T]] .
  eq toHL(M,(T,NTL)) = '_|_[$toHL(M,(T,NTL))] .
  eq $toHL(M,(T,TL)) = hl-inj(M,maximalSortAbove(M,leastSort(M,T)))[T], $toHL(M,TL) .
  eq $toHL(M,empty) = empty .

  --- Define Forgetful Functor over Heterogeneous Lists
  op toTL : Term -> [NeTermList] .
  eq toTL('_|_[T,NTL]) = $toTL((T,NTL)) .
  eq toTL('singleton[T]) = $toTL(T) .

  op $toTL : TermList -> TermList .
  eq $toTL((Q[T],TL)) = T,$toTL(TL) .
  eq $toTL(empty) = empty .

  --- Equational Laws (Left As Proof Obligations)
  --- For all
  --- [1] modules M
  --- [2] termlists NTL in M
  --- [3] terms T of sort HeterogeneousList in HL[M]
  eq toTL(toHL(M,NTL)) = NTL [nonexec] .
  eq toHL(M,toTL(T)) = T [nonexec] .
endfm

fmod EQUALITY-FUNCTOR is
  pr UNIT-FM .
  pr CTOR-SIG .

  var M : Module . var OS : OpDeclSet . var T T' : Term .

  --- PRE: Module does not have sorts/ops with the prefix/suffix @##/##@
  --- OUT: A module with an universal equality operator
  op equal-func : FModule -> FModule [memo] .
  eq equal-func(M) =
    setEqs(addOps((
     op '##/\##      : '@##Bool##@ '@##Bool##@ -> '@##Bool##@ [none].
     op '##false##   : nil                     -> '@##Bool##@ [ctor special(id-hook('SystemFalse, nil))].
     op '##true##    : nil                     -> '@##Bool##@ [ctor special(id-hook('SystemTrue,  nil))].
     op '##equal##   : 'Universal  'Universal  -> '@##Bool##@ [poly(1 2) special(
      id-hook  ('EqualitySymbol, nil)
      term-hook('equalTerm,      '##true##.@##Bool##@ )
      term-hook('notEqualTerm,   '##false##.@##Bool##@))].
     op '##unequal## : 'Universal  'Universal  -> '@##Bool##@ [poly(1 2) special(
      id-hook  ('EqualitySymbol, nil)
      term-hook('equalTerm,      '##false##.@##Bool##@)
      term-hook('notEqualTerm,   '##true##.@##Bool##@ ))].),
    addSorts('@##Bool##@,setOps(M,pruneBool(getOps(ctor-sig(M)))))),
     eq '##/\##['##true##.@##Bool##@, 'B:@##Bool##@] =         'B:@##Bool##@ [none].
     eq '##/\##['##false##.@##Bool##@,'B:@##Bool##@] = '##false##.@##Bool##@ [none].) .

  op check-equal   : FModule Term Term ~> Bool .
  eq check-equal(M,T,T')   =     $check-equal(getTerm(metaReduce(equal-func(M),  '##equal##[T,T']))) .

  op check-unequal : FModule Term Term ~> Bool .
  eq check-unequal(M,T,T') = not $check-equal(getTerm(metaReduce(equal-func(M),'##unequal##[T,T']))) .

  op $check-equal  : Term ~> Bool .
  eq $check-equal( '##true##.@##Bool##@) = true  .
  eq $check-equal('##false##.@##Bool##@) = false .

  --- TODO: deal with non-empty hooklists
  --- PRE: None
  --- OUT: An OpDeclSet with all SystemTrue/False attributes removed
  op pruneBool : OpDeclSet -> OpDeclSet .
  eq pruneBool(op Q:Qid : L:TypeList -> T:Type [A:AttrSet special(id-hook('SystemTrue,nil))]. OS) =
     pruneBool(op Q:Qid : L:TypeList -> T:Type [A:AttrSet]. OS) .
  eq pruneBool(op Q:Qid : L:TypeList -> T:Type [A:AttrSet special(id-hook('SystemFalse,nil))]. OS) =
     pruneBool(op Q:Qid : L:TypeList -> T:Type [A:AttrSet]. OS) .
  eq pruneBool(OS) = OS [owise] .

  op pruneBool : Module -> Module .
  eq pruneBool(M) = setOps(M,pruneBool(getOps(M))) .
endfm

fmod FRESH-BOOL-FUNCTOR is
  pr UNIQUE-PREFIX .
  pr UNIT-FM .

  var M : Module .
  var SortP : String .

  sort ModQidListPair .
  op ((_,_)) : Module QidList -> ModQidListPair [ctor] .

  op fresh-bool : Module -> ModQidListPair .
  eq fresh-bool(M) = fresh-bool(M,sortPrefix(M)) .

  op fresh-bool : Module String -> ModQidListPair .
  eq fresh-bool(M,SortP) = (addOps((op 'true  : nil -> qid(SortP + "Bool") [ctor].
                                    op 'false : nil -> qid(SortP + "Bool") [ctor].),
                            M), qid(SortP + "Bool")) .
endfm

fmod QID-TERMLIST-TUPLE is
  pr META-MODULE .
  sort QidTermListTuple .
  op ((_,_,_)) : Qid TermList TermList -> QidTermListTuple [ctor] .
endfm

view QidTermListTuple from TRIV to QID-TERMLIST-TUPLE is sort Elt to QidTermListTuple . endv

fmod PREDICATE-FUNCTOR is
  pr QID-JOIN .
  pr UNIQUE-PREFIX .
  pr UNIT-FM .
  pr MAP{Qid,QidTermListTuple} * (op _|->_ to _|=>_, op undefined to undefQTM) .
  pr FRESH-BOOL-FUNCTOR .

  var M : Module .
  var BoolS PredS : Sort .
  var Q SortP OpP : Qid .
  var LT RT : Term .
  var PTL NTL TL : TermList .
  var QTM : Map{Qid,QidTermListTuple} .

  op pred-functor : Module Map{Qid,QidTermListTuple} -> ModQidListPair .
  eq pred-functor(M,QTM) = pred-functor(fresh-bool(M,sortPrefix(M)),qid(sortPrefix(M)),qid(opPrefix(M)),QTM) .

  op pred-functor : ModQidListPair Qid Qid Map{Qid,QidTermListTuple} -> ModQidListPair .
  eq pred-functor((M,BoolS),SortP,OpP,QTM) = pred-functor(BoolS,SortP,OpP,QTM,M) .

  op pred-functor : Sort Qid Qid Map{Qid,QidTermListTuple} Module -> ModQidListPair .
 ceq pred-functor(BoolS,SortP,OpP,(Q |=> (PredS,PTL,NTL), QTM),M) =
    pred-functor(BoolS,SortP,OpP,QTM,
      addSorts(BoolS,
        addEqs(buildPredEqs(join(OpP Q),BoolS,PTL,NTL),
          addOps(op join(OpP Q) : PredS -> BoolS [ctor]., M))))
  if (PTL,NTL) : NeTermList .

  eq pred-functor(BoolS,SortP,OpP,empty,M) = (M,SortP OpP) .

  op buildPredEqs : Qid Sort TermList TermList -> EquationSet .
  eq buildPredEqs(Q,BoolS,PTL,NTL) =
    buildPredEqs(Q,PTL,join('true. BoolS))
    buildPredEqs(Q,NTL,join('false. BoolS)) .

  op buildPredEqs : Qid TermList Term -> EquationSet .
  eq buildPredEqs(Q,(LT,TL),RT) = (eq Q[LT] = RT [none]. buildPredEqs(Q,TL,RT)) .
  eq buildPredEqs(Q,empty,RT)   = none .
endfm

fmod TOP-MODULE is
  pr STRING-EXTRA .
  pr QIDTUPLESET  .
  pr META-LEVEL   .
  pr UNIT-FM      .
  pr CONVERSION   .

  var S S' : Sort   . var SS : SortSet .
  var K K' : Kind   . var KS : KindSet .
  var Y    : Type   . var YS : TypeList .
  var SR   : String . var M  : Module  .
  var N    : Nat    .

  --- map kinds to sorts
  op k2s-map   : Module          -> QidPairSet     [memo] .
  op k2s-map   : KindSet         -> QidPairSet     .
  op k2s       : KindSet         -> SortSet        .
  op k2s       : Kind            -> Sort           .
  op k2s       : String          -> Sort           .
  op k2s-map   : Module TypeList -> Type           .
  --- abbreviated kind to identifier map
  op k2s-map#  : Module          -> QidPairSet     [memo] .
  op k2s-map#  : KindSet Nat     -> QidPairSet     .
  op k2s-map#  : Module TypeList -> TypeList       .
  --- top the signature
  op top-subs  : Module KindSet -> SubsortDeclSet .
  op top-subs  : Sort SortSet   -> SubsortDeclSet .
  op top       : Module         -> Module         .

  eq k2s(none)           = none .
  eq k2s(K ; K' ; KS)    = k2s(K) ; k2s(K' ; KS) .
  eq k2s(K)              = k2s(string(K)) .
  eq k2s(SR)             = qid("|" + replace(substr(substr(SR,0,sd(length(SR),2)),2,sd(length(SR),4)),"`,","|") + "|") .

  eq k2s-map(M)          = k2s-map(getKinds(M)) .
  eq k2s-map(K ; KS)     = qp(K,k2s(K)) | k2s-map(KS) .
  eq k2s-map(none)       = none .

  eq k2s-map(M,Y YS)     = applyQPS!(getKind(M,Y),k2s-map(M)) k2s-map(M,YS) .
  eq k2s-map(M,nil)      = nil .

  eq k2s-map#(M)         = k2s-map#(getKinds(M),0) .
  eq k2s-map#(K ; KS,N)  = qp(K,qid("Kind#" + string(N,10))) | k2s-map#(KS,s(N)) .
  eq k2s-map#(none,N)    = none .

  eq k2s-map#(M,Y YS)    = applyQPS!(getKind(M,Y),k2s-map#(M)) k2s-map#(M,YS) .
  eq k2s-map#(M,nil)     = nil .

  eq top(M)              = addSorts(k2s(getKinds(M)),addSubsorts(top-subs(M,getKinds(M)),M)) .
  eq top-subs(M,K ; KS)  = top-subs(k2s(K),lesserSorts(M,K)) top-subs(M,KS) .
  eq top-subs(M,none)    = none .
  eq top-subs(S,S' ; SS) = subsort S' < S . top-subs(S,SS) .
  eq top-subs(S,none)    = none .
endfm

--- take a module and extend it with sets of equations
fmod EQUATIONSET-FUNCTOR is
  pr META-LEVEL .
  pr UNIT-FM .
  pr QID-JOIN .
  pr UNIQUE-PREFIX .

  --- module conversions
  op eqset-pair-func : Module         -> Module      [memo] .
  op eqset-func      : Module         -> Module      [memo] .
  op eqset-sort      : Module         -> Sort        .
  op eqsetp-sort     : Module         -> Sort        .
  op eq-opid         : Module         -> Qid         [memo] .
  op eqsetp-opid     : Module         -> Qid         [memo] .
  op eqset-opid      : Module         -> Qid         [memo] .
  op eqsetid-term    : Module         -> TermQid     [memo] .
  op eq-ops          : Module KindSet -> OpDeclSet   .
  op eq-eqs          : Module KindSet -> EquationSet .

  var M : Module . var K : Kind . var KS : KindSet .
  var T T' : Term . var A : AttrSet . var E : Equation . var ES ES' : EquationSet .

  --- extend module by topping it and then adding equations
  eq eqset-func(M) = addEqs(eq-eqs(M,getKinds(M)),addSorts(eqset-sort(M),addOps(eq-ops(M,getKinds(M)),M))) .
  eq eqset-pair-func(M) = addOps(op eqsetp-opid(M) : eqset-sort(M) eqset-sort(M) -> eqsetp-sort(M) [ctor].,addSorts(eqsetp-sort(M),eqset-func(M))) .

  --- fresh sort for equation sets
  eq eqset-sort(M)  = qid(sortPrefix(M) + "EqSet") .
  eq eqsetp-sort(M) = qid(sortPrefix(M) + "EqSetPair") .

  --- fresh operator ids for equation sets
  eq eq-opid(M)      = qid(opPrefix(M)   + "~") .
  eq eqset-opid(M)   = qid(opPrefix(M)   + "|") .
  eq eqsetp-opid(M)  = qid(opPrefix(M)   + "esp") .
  eq eqsetid-term(M) = qid("none." + string(eqset-sort(M))) .

  --- operator and equation declarations for equation sets
  eq eq-ops(M,K ; KS) = op eq-opid(M) : K K -> eqset-sort(M) [ctor comm] . eq-ops(M,KS) .
  eq eq-ops(M,none)   = (op eqset-opid(M) : eqset-sort(M) eqset-sort(M) -> eqset-sort(M) [ctor assoc comm id(eqsetid-term(M))] . op 'none : nil -> eqset-sort(M) [ctor] .) .
  eq eq-eqs(M,K ; KS) = (eq eq-opid(M)[qid("X:" + string(K)),qid("X:" + string(K))] = eqsetid-term(M) [none].) eq-eqs(M,KS) .
  eq eq-eqs(M,none)   = none .

  op toEqSetTerm : Module EquationSet ~> Term .
  eq toEqSetTerm(M,eq T = T' [A].)      = eq-opid(M)[T,T'] .
  eq toEqSetTerm(M,eq T = T' [A]. E ES) = eqset-opid(M)[toEqSetTerm1(M,eq T = T' [A]. E ES)] .
  eq toEqSetTerm(M,none)                = eqsetid-term(M) .

  op toEqSetTerm1 : Module EquationSet ~> TermList .
  eq toEqSetTerm1(M,eq T = T' [A]. ES) = eq-opid(M)[T,T'], toEqSetTerm1(M,ES) .
  eq toEqSetTerm1(M,none)              = empty .

  op toEqSetPairTerm : Module EquationSet EquationSet ~> Term .
  eq toEqSetPairTerm(M,ES,ES') = eqsetp-opid(M)[toEqSetTerm(M,ES),toEqSetTerm(M,ES')] .
endfm

--- Extension of the equationset functor that converts all equations to rules
--- This module should be semantically equivalent to the original
fmod RULIFY-FUNCTOR is
  pr EQUATIONSET-FUNCTOR .
  pr STMT-EXTRA .

  var EQ SQ : Qid .
  var U V : Term .
  var Y : Type .
  var A : AttrSet .
  var ES : EquationSet .
  var EC : EqCondition .
  var M : Module .

  op rulify : Qid Qid EquationSet -> RuleSet .
  eq rulify(EQ,SQ, eq U = V       [A] . ES) = ( rl U => V                     [A] .) rulify(EQ,SQ,ES) .
  eq rulify(EQ,SQ,ceq U = V if EC [A] . ES) = (crl U => V if rulify(EQ,SQ,EC) [A] .) rulify(EQ,SQ,ES) .
  eq rulify(EQ,SQ,(none).EquationSet)       =  none .

  op rulify : Qid Qid EqCondition -> Condition .
  eq rulify(EQ,SQ,U = V  /\ EC) = EQ[U,V] => SQ /\ rulify(EQ,SQ,EC) .
  eq rulify(EQ,SQ,U := V /\ EC) = V => U        /\ rulify(EQ,SQ,EC) .
  eq rulify(EQ,SQ,U : Y  /\ EC) = U : Y         /\ rulify(EQ,SQ,EC) .
  eq rulify(EQ,SQ,nil)          = nil .

  op rulify-func : Module -> SModule [memo] .
  eq rulify-func(M) =
    (setRls(eqset-func(setEqs(M,none)),rulify(eq-opid(M),eqsetid-term(M),getEqs(M)))) .
endfm

fmod TERMSUBSTPAIR is
  pr META-TERM .
  sort TermSubstPair .
  op ((_,_)) : Term Substitution -> TermSubstPair [ctor] .
endfm

fmod TERMSUBSTSETPAIR is
  pr TERMSUBSTPAIR .
  pr SUBSTITUTIONSET .
  sort TermSubstSetPair .
  subsort TermSubstPair < TermSubstSetPair .
  op ((_,_)) : Term SubstitutionSet -> TermSubstSetPair .
endfm

fmod TERMSUBSTPAIRSET is
  pr TERMSUBSTPAIR .
  pr TERMSET-FM .
  pr SUBSTITUTIONSET .
  sort TermSubstPairSet .
  subsort TermSubstPair < TermSubstPairSet .
  op _|_      : TermSubstPairSet TermSubstPairSet -> TermSubstPairSet [ctor assoc comm id: emptyTPS] .
  op emptyTPS :                                   -> TermSubstPairSet [ctor] .
  op _<<_     : TermSubstPairSet SubstitutionSet  -> TermSubstPairSet .
  op tsp-term : TermSubstPairSet                  -> TermSet .
  op tsp-sub  : TermSubstPairSet                  -> SubstitutionSet .

  var TPS : TermSubstPairSet . var TP TP' : TermSubstPair . var T : Term . var S S' : Substitution . var SS : SubstitutionSet .

  eq tsp-term(TPS | (T,S))    = T | tsp-term(TPS) .
  eq tsp-term(emptyTPS)       = emptyTermSet .
  eq tsp-sub(TPS | (T,S))     = S | tsp-sub(TPS) .
  eq tsp-sub(emptyTPS)        = empty .

  eq (TP | TP' | TPS) << SS            = (TP << SS) | ((TP' | TPS) << SS) .
  eq  emptyTPS        << SS            = emptyTPS .
  eq  TP              << (S | S' | SS) = (TP << S) | (TP << (S' | SS)) .
  eq  TP              << empty         = emptyTPS .
  eq (T,S)            << S'            = (T << S',S << S') .
endfm

fmod SUBSTITUTIONSET-AUX is
  pr SUBSTITUTION-AUX .
  pr SUBSTITUTIONSET .
  pr TERMSET-FM .
  pr MAYBE-QID .

  var S S' S2 : Substitution . var SS : SubstitutionSet .
  var T T' : Term . var TS : TermSet .
  var V V' : Variable . var QS : VariableSet . var VS : VarSubstitution .
  var SSK : [SubstitutionSet] . var U : Module . var Vars : VariableSet .

  --- OUT: QidSet composed of domain() of each substitution
  op domain : SubstitutionSet -> VariableSet .
  eq domain(S | S' | SS) = domain(S) ; domain(S' | SS) .
  eq domain(empty)       = none .

  --- OUT: SubstitutionSet where each substitution binding V <- T is
  ---      filtered out if V occurs in QS
  op filterNotIn : SubstitutionSet VariableSet -> SubstitutionSet .
  eq filterNotIn(S | S' | SS,QS) = filterNotIn(S,QS) | filterNotIn(S' | SS,QS) .
  eq filterNotIn(empty,QS)       = empty .

  --- OUT: A TermSet of instances of Term by application with each Substitution in SubstitutionSet
  op _<<_ : TermSet SubstitutionSet -> TermSet .
  eq T << (S | S' | SS)  = (T << S) | (T << (S' | SS)) .
  eq T << empty          = emptyTermSet .
  eq (T | T' | TS) << SS = (T << SS) | ((T' | TS) << SS) .
  eq emptyTermSet << SS  = emptyTermSet .


  --- OUT: A SubstitutionSet identical to input but where each assignment in Substitution is removed
  op remove : SubstitutionSet Substitution -> SubstitutionSet .
  eq remove(S | S' | SS,S2) = remove(S,S2) | remove(S' | SS,S2) .
  eq remove(empty,S2)       = empty .

  --- OUT: A SubstitutionSet of Assignments built by blowing this Substitution apart
  op explode : Substitution -> SubstitutionSet .
  eq explode(V <- T ; S) = (V <- T) | explode(S) .
  eq explode(none) = empty .

  --- OUT: Get first error from SubstitutionSet
  eq errsubMsg(errsub(QL:QidList) | SSK) = QL:QidList .

  --- ### New
  --- OUT: A set of assignments mapping Variable to each Term
  op assignments : Variable TermSet -> SubstitutionSet .
  eq assignments(V,T | TS) = (V <- T) | assignments(V,TS) .
  eq assignments(V,emptyTermSet) = empty .

  --- OUT: true iff all Substitutions are well-formed
  op wellFormedSet : Module SubstitutionSet -> Bool .
  eq wellFormedSet(U,S | SS) = wellFormed(U,S) and-then wellFormedSet(U,SS) .
  eq wellFormedSet(U,(empty).SubstitutionSet) = true .

  --- OUT: returns domain iff all Substitutions share the same domain
  op sharedDomain : SubstitutionSet ~> VariableSet .
  eq sharedDomain(S | SS) = sharedDomain(domain(S),SS) .

  op sharedDomain : VariableSet SubstitutionSet ~> VariableSet .
  eq sharedDomain(Vars,S | SS) =
    if Vars == domain(S) then sharedDomain(Vars,SS) else errQid('Substitution 'domains 'not 'identical) fi .
  eq sharedDomain(Vars,empty) = Vars .
endfm

--- TODO: compare this code with minimizeBindingsTerm in FULL-MAUDE
--- operations like metaUnify, metaDisjointUnify, etc... generate fresh variable
--- names for all terms invovled---however, sometimes, it is desirable to preserve
--- the variable names originally chosen by the user---this module implemnts a
--- function which will ``reuse'' user-provided variables as often as possible
fmod RECLAIM-VARS is
  pr SUBSTITUTION-REFINEMENT .
  pr SUBSTITUTIONSET .
  pr SUBSTITUTION-AUX .
  op reclaim  : VariableSet SubstitutionSet           -> SubstitutionSet .
  op reclaim' : VariableSet Substitution              -> [Substitution] .
  op reclaim' : VariableSet Substitution Substitution -> Substitution .
  op filter   : SubstitutionSet                       -> SubstitutionSet .

  var V : Variable . var T : Term . var S S' : Substitution . var SS : SubstitutionSet . var VS : VariableSet .

  --- INP: VariableSet SubstitutionSet:SS
  --- PRE: domain(SS) intersected with range(SS) is empty
  --- OUT: A new SubstitutionSet where each substitution is identical
  ---      to the previous one except that alpha renamings V <- V'
  ---      are thrown away and replaced by identity mapping V <- V.
 ceq reclaim'(VS,S)             = reclaim'(VS,S,none) if intersection(domain(S),range(S)) == none .
  eq reclaim'(VS,V <- T ; S,S') = if T :: Variable and-then V in VS and-then not T in VS
                                   then reclaim'(VS,S << (T <- V),(S' << (T <- V)) ; V <- V) else reclaim'(VS,S,S' ; V <- T) fi .
  eq reclaim'(VS,none,S')       = S' .

  eq reclaim(VS,S | SS) = reclaim'(VS,S) | reclaim(VS,SS) .
  eq reclaim(VS,empty)  = empty .

  --- INP: SubsitutionSet
  --- PRE: None
  --- OUT: An identical SubstitutionSet where each identity
  ---      mapping V <- V is removed.
  eq filter((S ; V <- V) | SS) = filter(S | SS) .
  eq filter(SS) = SS [owise] .
endfm

view Substitution from TRIV to META-LEVEL is sort Elt to Substitution . endv

--- this module represents a lazily generated stream of substitutions
--- useful for representing the solutions to a unification problem, etc...
fmod SUBSTITUTION-STREAM is
  pr STREAM{Substitution} .
  pr SUBSTITUTIONSET .
  op set : Stream{Substitution} -> SubstitutionSet .
  var X : Substitution . var S : [Stream{Substitution}] .
  eq set(X & S) = X | set(S) .
  eq set(end) = empty .
endfm

--- this module provides functionality to add a set of variables into a module
--- as FRESH constants (by using the functionality of opPrefix above); the function
--- returns a new module as well as an assignment mapping each variable into its
--- fresh constant --- this assignment can later be used to decode the new term
--- back into its original form
fmod VARIABLES-TO-CONSTANTS is
  pr TERM-EXTRA .              --- for getName()/repeatedNames()
  pr UNIT-FM .                 --- for addOps()
  pr QID-JOIN .                --- for join()
  pr UNIQUE-PREFIX .           --- for opPrefix()
  pr SUBSTITUTION-REFINEMENT . --- for sort ConstSubstitution
  pr SUBSTITUTIONSET .         --- for sort SubstitutionSet
  pr OPDECLSET-EXTRA .         --- for qid()

  sort ModuleSubstPair .
  op ((_,_)) : Module Substitution -> ModuleSubstPair [ctor] .
  op mod : ModuleSubstPair ~> Module .
  op sub : ModuleSubstPair ~> Substitution .

  sort ConstGenStrategy .
  ops simple prefix full : -> ConstGenStrategy [ctor] .

  op  varsToConsts  : Module ConstGenStrategy QidSet                            -> [Module] .
  op  varsToConsts# : Module ConstGenStrategy QidSet                            -> [ModuleSubstPair] .
  op  varsToConsts# : Module ConstGenStrategy QidSet Qid OpDeclSet Substitution -> [ModuleSubstPair] .

  op  constsToVars  : ConstSubstitution Term                                    -> Term .
  op  constsToVars  : ConstSubstitution Qid TermList TermList                   -> TermList .
  op  constsToVars  : ConstSubstitution SubstitutionSet                         -> SubstitutionSet .

  var M : Module . var V : Variable . var C : Constant . var Q : Qid .
  var QS : QidSet . var TL TL' : TermList . var T : Term . var SS : SubstitutionSet .
  var S S' : Substitution . var P : Qid . var O : OpDeclSet . var CG : ConstGenStrategy .
  var TQ : TermQid . var CS : ConstSubstitution .


  --- ### New
  --- INP: Module ConstGenStrategy QidSet (Variables)
  --- PRE: [1] QidSet should be a set of variables
  ---      [2] if strategy is simple, variable names should be
  ---          disjoint from all constant operator names
  --- OUT: A new module where variables have been added as constants
  eq mod((M,CS)) = M .
  eq sub((M,CS)) = CS .
  eq varsToConsts(M,CG,QS)             = mod(varsToConsts#(M,CG,QS)) .
  eq varsToConsts#(M,CG,QS)            = varsToConsts#(M,CG,QS,qid(opPrefix(M)),none,none) .
  eq varsToConsts#(M,CG,V ; QS,P,O,CS) = varsToConsts#(M,CG,QS,P,O newConstOp(CG,P,V),CS ; V <- newConstSym(CG,P,V)) .
 ceq varsToConsts#(M,CG,none,P,O,CS)   = (addOps(O,M),CS)
  if CG =/= simple or-else intersection(qid(O),qid(getOps(M))) == none .

  op newConstName : ConstGenStrategy Qid Variable -> Qid .
  eq newConstName(simple,P,V) = getName(V) .
  eq newConstName(prefix,P,V) = join(P getName(V)) .
  eq newConstName(full,P,V) = join(P getName(V) '| getType(V)) .

  op newConstOp : ConstGenStrategy Qid Variable -> OpDecl .
  eq newConstOp(CG,P,V) = (op newConstName(CG,P,V) : nil -> getType(V) [none] .) .

  op newConstSym : ConstGenStrategy Qid Variable -> Constant .
  eq newConstSym(CG,P,V) = join(newConstName(CG,P,V) '. getType(V)) .

  --- INP: Substitution (Variables to fresh Constants) Term/SubstitutionSet
  --- PRE: None
  --- OUT: Identical to Term/SubstitutionSet except in Term/Codomain of SubstitutionSet
  ---      each occurrence of a constant in the codomain of Substitution is
  ---      replaced by the variable which is assigned to it
  --- NB:  the first equation is not strictly necessary but it optimizes for the common
  ---      case when the substitution is empty
  eq constsToVars((none).Substitution,T) = T .
  eq constsToVars(CS,Q[TL])              = constsToVars(CS,Q,TL,empty) .
  eq constsToVars(CS,V)                  = V .
  eq constsToVars(CS ; V <- C,C)         = V .
  eq constsToVars(CS,C)                  = C [owise] .
  eq constsToVars(CS,Q,(T,TL),TL')       = constsToVars(CS,Q,TL,(TL',constsToVars(CS,T))) .
  eq constsToVars(CS,Q,empty,TL')        = Q[TL'] .
  ---
  eq constsToVars(CS,S | S' | SS)             = constsToVars(CS,S) | constsToVars(CS,S' | SS) .
  eq constsToVars(CS,(empty).SubstitutionSet) = (empty).SubstitutionSet .
  eq constsToVars(CS,V <- T ; S)              = V <- constsToVars(CS,T) ; constsToVars(CS,S) .
  eq constsToVars(CS,(none).Substitution)     = (none).Substitution .
endfm

fmod VARIABLES-TO-CONSTANTS-FIXED-SIGNATURE is
  pr QID-JOIN .
  pr QIDSET-REFINEMENT .
  pr UNIT-FM .
  pr UNIQUE-PREFIX .

  var SQ OQ Q : Qid .
  var M : Module .
  var S : Sort .
  var SS : SortSet .
  var V : Variable .
  var C : Constant .
  var VS : VariableSet .
  var N : Nat .
  var T : Term .
  var L : TermList .
  var NL : NeTermList .
  var NVM : NatVarMap .

  sort NatVarMapping NatVarMap .
  subsort NatVarMapping < NatVarMap .
  op _->_       : Nat Variable        -> NatVarMapping [ctor] .
  op _::_       : NatVarMap NatVarMap -> NatVarMap     [ctor assoc comm id: .NatVarMap] .
  op .NatVarMap :                     -> NatVarMap     [ctor] .

  --- Fixed Identity Functor
  --------------------------
  op fixedIdFunc : Module -> Module .
  eq fixedIdFunc(M) = fixedIdFunc(M,qid(opPrefix(M)),qid(sortPrefix(M))) .

  op fixedIdFunc : Module Qid Qid -> Module .
  eq fixedIdFunc(M,OQ,SQ) =
    addOps(fiInjections(OQ,SQ,getSorts(M))
           op fiZeroSym(OQ) : nil           -> fiNatSort(SQ) [ctor].
           op fiSuccSym(OQ) : fiNatSort(SQ) -> fiNatSort(SQ) [ctor iter].,
      addSorts(fiNatSort(SQ),M)) .

  --- Module signature extension
  ------------------------------
  op fiInjections : Qid Qid SortSet -> OpDeclSet .
  eq fiInjections(OQ,SQ,S ; SS) =
    (op fiVarSym(OQ,S) : fiNatSort(SQ) -> S [ctor] .)
    fiInjections(OQ,SQ,SS) .
  eq fiInjections(OQ,SQ,none) = none .

  op fiNatSort : Qid -> Sort .
  eq fiNatSort(SQ) = join(SQ 'IdNat) .

  op fiZeroSymOp : Qid Qid -> Constant .
  eq fiZeroSymOp(OQ,SQ) = join(fiZeroSym(OQ) '. fiNatSort(SQ)) .

  op fiVarSym : Qid Sort -> Qid .
  eq fiVarSym(OQ,S) = join(OQ 'Var S) .

  op fiZeroSym : Qid -> Constant .
  eq fiZeroSym(OQ) = join(OQ 'fz) .

  op fiSuccSym : Qid -> Qid .
  eq fiSuccSym(OQ) = join(OQ 'fs) .

  --- NatVarMap Construction and Application
  ------------------------------------------
  op getNatVarMap : VariableSet Nat -> NatVarMap .
  eq getNatVarMap(V ; VS,N) = getNatVarMap(VS,s(N)) :: N -> V .
  eq getNatVarMap(none,N)   = .NatVarMap .

  op getNat : NatVarMap Variable ~> Nat .
  eq getNat((N -> V) :: NVM,V) = N .

  op getVar : NatVarMap Nat ~> Variable .
  eq getVar((N -> V) :: NVM,N) = V .

  --- Var to Const Transformation and Inverse
  -------------------------------------------
  op varsToConsts : Qid Qid NatVarMap TermList ~> TermList .
  eq varsToConsts(OQ,SQ,NVM,C    ) = C .
  eq varsToConsts(OQ,SQ,NVM,V    ) = fiVarSym(OQ,getType(V))[fiNat(OQ,SQ,getNat(NVM,V))] .
  eq varsToConsts(OQ,SQ,NVM,Q[NL]) = Q[varsToConsts(OQ,SQ,NVM,NL)] .
  eq varsToConsts(OQ,SQ,NVM,(T,L)) = varsToConsts(OQ,SQ,NVM,T),varsToConsts(OQ,SQ,NVM,L) .
  eq varsToConsts(OQ,SQ,NVM,empty) = empty .

  op constsToVars : Qid NatVarMap TermList -> TermList .
  eq constsToVars(OQ,NVM,C      ) = C .
  eq constsToVars(OQ,NVM,V      ) = V .
  eq constsToVars(OQ,NVM,Q[T]   ) = if parseFiVar(OQ,Q,T) :: Nat then getVar(NVM,parseFiVar(OQ,Q,T)) else Q[constsToVars(OQ,NVM,T)] fi .
  eq constsToVars(OQ,NVM,Q[T,NL]) = Q[constsToVars(OQ,NVM,(T,NL))] .
  eq constsToVars(OQ,NVM,(T,L)  ) = constsToVars(OQ,NVM,T),constsToVars(OQ,NVM,L) .
  eq constsToVars(OQ,NVM,empty  ) = empty .

  --- Auxiliary Functions
  -----------------------
  op parseFiVar : Qid Qid Term ~> Nat .
  op parseFiVar : Bool Term ~> Nat .
  ----------------------------------
  eq parseFiVar(OQ,Q,T)    = parseFiVar(substr(string(Q),0,length(string(OQ)) + 3) == (string(OQ) + "Var"),T) .
  eq parseFiVar(true,C)    = 0 .
  eq parseFiVar(true,Q[T]) = rat(substr(string(Q),s(rfind(string(Q),"^",length(string(Q)))),length(string(Q))),10) .

  op fiNat : Qid Qid Nat -> Term .
  eq fiNat(OQ,SQ,s(N)) = join(fiSuccSym(OQ) '^ qid(string(s(N),10)))[fiZeroSymOp(OQ,SQ)] .
  eq fiNat(OQ,SQ,0   ) = fiZeroSymOp(OQ,SQ) .
endfm

--- ### New
fmod GENERIC-PRINTER is
  pr META-LEVEL .
  pr CONVERSION .
  pr TERMSET-FM .
  pr UNIT-FM    .
  pr MAYBE-QID  .

  var A A' : Assignment .
  var B : Bool .
  var M : Module  .
  var N : Nat .
  var NL : NatList .
  var Q Q' : Qid .
  var QL : QidList .
  var RP RP' : ResultPair .
  var RP? : [ResultPair] .
  var SB : Substitution .
  var T T' : Term .
  var TS : TermSet .
  var V : Variable .

  op &mt : -> Qid .
  op &sp : -> Qid .
  eq &mt = qid("")  .
  eq &sp = qid(" ") .

  op printSpaces : Nat -> QidList .
  eq printSpaces(s(N)) = &sp printSpaces(N) .
  eq printSpaces(0) = nil .

  op printPad : Qid Nat -> QidList .
  eq printPad(Q,N) = Q if length(string(Q)) >= N then nil else printSpaces(sd(length(string(Q)),N)) fi .

  op printTerm : Module Term -> QidList .
  eq printTerm(M,T) = metaPrettyPrint(M,T) .

  op printTermSet : Module TermSet -> QidList .
  eq printTermSet(M,T | T' | TS) = printTerm(M,T) '`, printTermSet(M,T' | TS) .
  eq printTermSet(M,T) = metaPrettyPrint(M,T) .
  eq printTermSet(M,emptyTermSet) = &mt .

  op printSub : Module Substitution -> QidList .
  eq printSub(M,V <- T) = metaPrettyPrint(M,V) '<- metaPrettyPrint(M,T) .
  eq printSub(M,A ; A' ; SB) = printSub(M,A) '; printSub(M,A' ; SB) .
  eq printSub(M,none) = 'identity .

  op printMaybeQid : MaybeQid Qid -> Qid .
  eq printMaybeQid(noqid,Q') = Q' .
  eq printMaybeQid(Q,Q') = Q .

  op printNatList : NatList QidList -> QidList .
  eq printNatList(N NL,QL) = printNatList(NL,QL qid(string(N,10))) .
  eq printNatList((nil).NatList,QL) = QL .

  op printN : Nat QidList -> QidList .
  eq printN(N, nil) = nil .
  eq printN(0, QL) = nil .
  eq printN(s N, Q QL) = Q printN(N, QL) .

  op printSyntaxError : [ResultPair?] QidList -> QidList .
  eq printSyntaxError(noParse(N), QL)
    = '\r 'Parse 'error 'in '\o '\s printN(N + 1, QL) '\r '<---*HERE* '\o .
  eq printSyntaxError(ambiguity(RP, RP'), QL)
    = '\r 'Ambiguous 'parsing 'for '\o '\s QL '\o .
  eq printSyntaxError(RP?, QL) = QL [owise] .

  --- print meta representation of terms
  op printMeta : Term -> QidList .
  eq printMeta(T) = metaPrettyPrint(['META-TERM],upTerm(T)) .

  op printMeta : Bool -> Qid .
  eq printMeta(true) = 'true .
  eq printMeta(false) = 'false .

  op printMeta : Qid -> Qid .
  eq printMeta(Q) = qid("'" + string(Q)) .

  op printMeta : Module Bool -> QidList .
 ceq printMeta(M,B) = 'upModule '`( printMeta(getName(M)) '`, printMeta(B) '`)
  if getName(M) :: Qid .
  eq printMeta(M,B) = '`( 'Error: 'printMeta 'module 'failure '`) [owise] .
endfm

fmod META-PARSE is
  pr LEXICAL .
  pr META-LEVEL .

  var U  : Module .
  var S  : String .
  var Y  : Type   .
  var Y? : Type?  .
  var T  : Term   .

  op metaParse : Module String Type? ~> ResultPair? .
  eq metaParse(U,S,Y?) = metaParse(U,tokenize(S),Y?) .

  op stringToTerm : Module String ~> Term .
  eq stringToTerm(U,S) = stringToTerm(metaParse(U,S,anyType)) .

  op stringToTerm : ResultPair? ~> Term .
  eq stringToTerm({T,Y}) = T .
endfm

--- This module stores a mapping of qids to qidlists
--- it is designed to be used for hooking in new functionality into an existing function at runtime
--- to use it, one should declare a function in advance of the form:
---
--- op my-func : MaybeQid ...OtherArgs... -> Result .
---
--- The MaybeQid argument controls version of the function we wish to use
--- Then, the function registry will have an entry of the form:
---
--- 'my-func |-> 'impl-id1 ; 'impl-id2 ; ...
---
--- For any given function in the registry, there should be only one implementation with any given id.
--- Duplication of function names or implementation names for one function is an error.
--- Then, the caller of the function can inspect the registry to see which implementations are available
--- and then pick one.
fmod FUNCTION-REGISTRY is
  pr MAP{Qid,QidList} * (sort Map{Qid,QidList} to FunctionRegistry, sort Entry{Qid,QidList} to FunctionEntry) .
endfm

fmod RENAME-TERM is
  pr META-TERM .
  pr GTERMLIST-REFINEMENT .
  pr SUBSTITUTION-REFINEMENT .
  pr SUBSTITUTION-AUX .

  var N : Nat . var V V' : Variable  . var TL : TermList    . var C : Constant . var S : VarSubstitution .
  var Q : Qid . var L L' : GTermList . var CL : NeCTermList . var T T' : GTerm .
  var TQ TQ' : TermQid . var TQS : TermQidSet . var STR : String . var KN : [Nat] .
  var VS : VariableSet .

  sort NameData .
  op [_,_] : Nat VarSubstitution -> NameData [ctor] .

  sort RenamedTerm RenamedGTerm RenamedTermList RenamedGTermList .
  subsort RenamedTerm < RenamedTermList RenamedGTerm < RenamedGTermList .
  op [_,_] : NameData Term      -> RenamedTerm      [ctor] .
  op [_,_] : NameData GTerm     -> RenamedGTerm     [ctor] .
  op [_,_] : NameData TermList  -> RenamedTermList  [ctor] .
  op [_,_] : NameData GTermList -> RenamedGTermList [ctor] .

  op nullNameData : -> NameData .
  eq nullNameData = [0,none] .

  op nameData : Nat -> NameData .
  eq nameData(N) = [s(N),none] .

  op nameData : VariableSet -> NameData .
  eq nameData(VS) = [0,idsub(VS)] .

  op clear : NameData -> NameData .
  eq clear([N,S]) = [N,none] .

  op renameVars  : GTermList          -> GTermList .
  op renameVars  : NameData GTermList -> GTermList .
  op #renameVars : NameData GTermList -> RenamedGTermList .
  ---------------------------------------------------------
  eq  renameVars(L)       = rvGetObj(#renameVars([0,none],L)) .
  eq  renameVars([N,S],L) = rvGetObj(#renameVars([N,S],   L)) .
  eq #renameVars([N,S],L) = rvRenameList([N,S],L,empty) .

  op rvRenameList : NameData GTermList GTermList    -> RenamedGTermList .
  op rvRenameList : RenamedGTerm GTermList GTermList -> RenamedGTermList .
  -----------------------------------------------------------------------
  eq rvRenameList([N,S],(T,L),L') = rvRenameList(rvRenameTerm([N,S],T),L,L') .
  eq rvRenameList([N,S],empty,L') = [[N,S],L'] .
  eq rvRenameList([[N,S],T],L,L') = rvRenameList([N,S],L,(L',T)) .

  op rvRenameTerm : NameData GTerm       -> RenamedGTerm .
  op rvRenameTerm : Qid RenamedGTermList -> RenamedGTerm .
  --------------------------------------------------------
  eq rvRenameTerm([N,S],Q[CL]) = rvRenameTerm(Q,rvRenameList([N,S],CL,empty)) .
  eq rvRenameTerm([N,S],Q[TL]) = rvRenameTerm(Q,rvRenameList([N,S],TL,empty)) .
  eq rvRenameTerm([N,S],C)     = [[N,S],C] .
  eq rvRenameTerm([N,S],V)     = rvRenameVar([N,S],getRenaming(V,S),V) .
  eq rvRenameTerm(Q,[[N,S],L]) = [[N,S],Q[L]] .

  op rvRenameVar : NameData Variable          -> RenamedGTerm .
  op rvRenameVar : NameData MaybeQid Variable -> RenamedGTerm .
  -------------------------------------------------------------
  eq rvRenameVar([N,S],V',V)    = [[N,S],V'] .
  eq rvRenameVar([N,S],noqid,V) = [[s(N),S ; V <- rvVar(N,V)],rvVar(N,V)] .

  op rvGetObj : RenamedGTermList ~> GTermList .
  op rvGetSub : RenamedGTermList ~> Substitution .
  op rvVar    : Nat Variable     -> Variable  .
  ----------------------------------------------
  eq rvGetObj([[N,S],L:[Term]]) = L:[Term] .
  eq rvGetSub ([[N,S],L:[Term]]) = S .
  eq rvVar(N,V) =
    qid("&"          +
        string(N,10) +
        ":"          +
        substr(string(V), rfind(string(V), ":", length(string(V))) + 1, length(string(V)))) .

  op freshifyVars : Nat TermQidSet -> Substitution .
  op freshifyVars : Nat Substitution TermQidSet -> Substitution .
  --------------------------------------------------
  eq freshifyVars(N,TQS)   = rvGetSub(#renameVars([s(N),none],TermList(TQS))) .
  eq freshifyVars(N,S,TQS) = rvGetSub(#renameVars([s(N),S],   TermList(TQS))) .

  op maxVar : TermQid -> Nat .
  op maxVar : GTermList -> Nat .
  op maxVar : TermQidSet -> Nat .
  -------------------------------
  eq maxVar(C) = 0 .
  eq maxVar(V) = parseIndex(string(getName(V))) .

  eq maxVar(Q[TL]) = maxVar(TL) .
  eq maxVar(Q[CL]) = maxVar(CL) .
  eq maxVar((T,T',L)) = max(maxVar(T),maxVar((T',L))) .
  eq maxVar(empty) = 0 .

  eq maxVar(TQ ; TQ' ; TQS) = max(maxVar(TQ),maxVar(TQ' ; TQS)) .
  eq maxVar(none) = 0 .

  op parseIndex : String ~> Nat .
  op parseIndex : FindResult String ~> Nat .
  op parseIndex : Nat ~> Nat .
  ----------------------------
  eq parseIndex(STR) = parseIndex(rfind(STR,"&",length(STR)),STR) .

  eq parseIndex(notFound,STR) = 0 .
  eq parseIndex(N,       STR) = parseIndex(rat(substr(STR,s(N),length(STR)),10)) .

  eq parseIndex(KN) = if KN :: Nat then KN else 0 fi .
endfm

fmod RENAME-TERM-AUX is
  pr MAYBE-QID .
  pr RENAME-TERM .
  pr TERMSET-FM .
  pr SUBSTITUTIONSET .
  pr UNIT-FM .

  var D : NameData . var T T' T1 T2 T1' T2' : Term . var S S' : TermSet .
  var G : GTerm . var L L' : GTermList . var N : Nat .
  var SB SB' : Substitution . var SBS : SubstitutionSet .
  var V : Variable . var U : Module .
  var E : Equation . var ES ES' : EquationSet .
  var R : Rule . var RS RS' : RuleSet .
  var EC : EqCondition . var C C' : Condition .
  var AS : AttrSet . var Q? : MaybeQid . var X : Sort .

  sort RenamedTermSet .
  subsort RenamedTerm < RenamedTermSet .
  op [_,_] : NameData TermSet -> RenamedTermSet [ctor] .
  ------------------------------------------------------
  ------------------------------------------------------

  op renameVars  : TermSet -> TermSet .
  op renameVars  : NameData TermSet -> TermSet .
  op #renameVars : NameData TermSet -> RenamedTermSet .
  --- NB: typings needed for preregularity
  op renameVars  : Term -> Term .
  op renameVars  : NameData Term -> Term .
  op #renameVars : NameData Term -> RenamedTerm .
  -----------------------------------------------------
  eq  renameVars(S)              = rvGetObj(#renameVars([0,none],S)) .
  eq  renameVars(D,S)            = rvGetObj(#renameVars(D,S)) .
  eq #renameVars(D,T | T' | S)   = rvRenameTS(D,T | T' | S,emptyTermSet) .
  eq #renameVars(D,emptyTermSet) = [D,emptyTermSet] .

  op rvRenameTS : NameData TermSet TermSet    -> RenamedTermSet .
  op rvRenameTS : RenamedTerm TermSet TermSet -> RenamedTermSet .
  ---------------------------------------------------------------
  eq rvRenameTS(D,T | S,S')        = rvRenameTS(rvRenameTerm(D,T),S,S') .
  eq rvRenameTS(D,emptyTermSet,S') = [D,S'] .
  eq rvRenameTS([D,T],S,S')        = rvRenameTS(D,S,S' | T) .

  op renameDisjVars : GTermList -> GTermList .
  op renameDisjVars : Nat GTermList -> GTermList .
  op #renameDisjVars : Nat GTermList -> RenamedGTermList .
  --------------------------------------------------------
  eq  renameDisjVars(L)   = rvGetObj(#renameDisjVars(0,L)) .
  eq  renameDisjVars(N,L) = rvGetObj(#renameDisjVars(N,L)) .
  eq #renameDisjVars(N,L) = rvRenameListD([N,none],L,empty) .

  op rvRenameListD : NameData GTermList GTermList -> RenamedGTermList .
  op rvRenameListD : RenamedGTerm GTermList GTermList -> RenamedGTermList .
  -------------------------------------------------------------------------
  eq rvRenameListD(D,(G,L),L') = rvRenameListD(rvRenameTerm(clear(D),G),L,L') .
  eq rvRenameListD(D,empty,L') = [clear(D),L'] .
  eq rvRenameListD([D,G],L,L') = rvRenameListD(D,L,(L',G)) .


  sort RenamedSubstitution .
  op [_,_] : NameData Substitution -> RenamedSubstitution [ctor] .
  ----------------------------------------------------------------
  ----------------------------------------------------------------
  op rvGetObj : RenamedSubstitution -> Substitution .
  eq rvGetObj([D,SB]) = SB .

  op renameVars : Substitution -> Substitution .
  op renameVars : NameData Substitution -> Substitution .
  op #renameVars : NameData Substitution -> RenamedSubstitution .
  ---------------------------------------------------------------
  eq  renameVars(SB)   = renameVars(nullNameData,SB) .
  eq  renameVars(D,SB) = rvGetObj(#renameVars(D,SB)) .
  eq #renameVars(D,SB) = rvRenameSub(D,SB,none) .

  op rvRenameSub : NameData Substitution Substitution -> RenamedSubstitution .
  op rvRenameSub : RenamedTerm Variable Substitution Substitution -> RenamedSubstitution .
  ----------------------------------------------------------------------------------------
  eq rvRenameSub(D,V <- T ; SB,SB') = rvRenameSub(rvRenameTerm(D,T),V,SB,SB') .
  eq rvRenameSub(D,none,SB')        = [D,SB'] .
  eq rvRenameSub([D,T'],V,SB,SB')   = rvRenameSub(D,SB,SB' ; V <- T') .

  op renameVars : NameData SubstitutionSet -> SubstitutionSet .
  -------------------------------------------------------------
  eq renameVars(D,SB | SBS) = renameVars(D,SB) | renameVars(D,SBS) .
  eq renameVars(D,(empty).SubstitutionSet) = empty .

  --- Code to consistently and safely rename all equations and rules in a module
  --- Useful for calling after module transformations
  op renameVars : Module -> Module .
  op renameVars : NameData Module -> Module .
  -------------------------------------------
  eq renameVars(U)   = renameVars(nullNameData,U) .
  eq renameVars(D,U) = setRls(setEqs(U,renameVars(D,getEqs(U),none)),renameVars(D,getRls(U),none)) .

  op renameVars : NameData EquationSet EquationSet -> EquationSet .
  op renameVars : NameData RuleSet RuleSet -> RuleSet .
  -----------------------------------------------------
  eq renameVars(D,E ES,ES') = renameVars(D,ES,ES' rvRenameEq(D,E)) .
  eq renameVars(D,none,ES') = ES' .

  eq renameVars(D,R RS,RS') = renameVars(D,RS,RS' rvRenameRl(D,R)) .
  eq renameVars(D,none,RS') = RS' .

  op rvRenameEq : NameData Equation -> Equation .
  op rvRenameRl : NameData Rule -> Rule .
  op rvRenameEq : RenamedTermList Equation -> Equation .
  op rvRenameRl : RenamedTermList Rule -> Rule .
  ----------------------------------------------
  eq rvRenameEq(D, eq T =  T'       [AS].) = rvRenameEq(#renameVars(D,(T,T')), eq T =  T'       [AS].) .
  eq rvRenameEq(D,ceq T =  T' if EC [AS].) = rvRenameEq(#renameVars(D,(T,T')),ceq T =  T' if EC [AS].) .
  eq rvRenameRl(D, rl T => T'       [AS].) = rvRenameRl(#renameVars(D,(T,T')), rl T => T'       [AS].) .
  eq rvRenameRl(D,crl T => T' if C  [AS].) = rvRenameRl(#renameVars(D,(T,T')),crl T => T' if C  [AS].) .

  eq rvRenameEq([D,(T1,T2)], eq T =  T'       [AS].) =  eq T1 =  T2                     [AS]. .
  eq rvRenameEq([D,(T1,T2)],ceq T =  T' if EC [AS].) = ceq T1 =  T2 if renameCond(D,EC) [AS]. .
  eq rvRenameRl([D,(T1,T2)], rl T => T'       [AS].) =  rl T1 => T2                     [AS]. .
  eq rvRenameRl([D,(T1,T2)],crl T => T' if C  [AS].) = crl T1 => T2 if renameCond(D,C)  [AS]. .

  sort RenamedCondition .
  op [_,_] : NameData Condition -> RenamedCondition [ctor] .
  ----------------------------------------------------------
  ----------------------------------------------------------
  op rvGetObj : RenamedCondition -> Condition .
  eq rvGetObj([D,C]) = C .

  op  renameCond : Condition -> Condition .
  op  renameCond : NameData Condition -> Condition .
  op #renameCond : NameData Condition -> RenamedCondition .
  ---------------------------------------------------------
  eq  renameCond(C)   = renameCond(nullNameData,C) .
  eq  renameCond(D,C) = rvGetObj(#renameCond(D,C)) .
  eq #renameCond(D,C) = #rvRenameCd(D,C,nil) .

  op #rvRenameCd : NameData Condition Condition -> RenamedCondition .
  op #rvRenameCd : RenamedTermList Qid MaybeQid Condition Condition -> RenamedCondition .
  ---------------------------------------------------------------------------------------
  eq #rvRenameCd(D,T1 =  T2 /\ C,C')  = #rvRenameCd(#renameVars(D,(T1,T2)),'=, noqid,C,C') .
  eq #rvRenameCd(D,T1 :  X  /\ C,C')  = #rvRenameCd(#renameVars(D, T1    ),':, X,    C,C') .
  eq #rvRenameCd(D,T1 := T2 /\ C,C')  = #rvRenameCd(#renameVars(D,(T1,T2)),':=,noqid,C,C') .
  eq #rvRenameCd(D,T1 => T2 /\ C,C')  = #rvRenameCd(#renameVars(D,(T1,T2)),'=>,noqid,C,C') .
  eq #rvRenameCd(D,nil,          C')  = [D,C'] .

  eq #rvRenameCd([D,(T1',T2')],'=, Q?,C,C') = #rvRenameCd(D,C,C' /\ T1' =  T2') .
  eq #rvRenameCd([D, T1'     ],': ,X, C,C') = #rvRenameCd(D,C,C' /\ T1' :  X  ) .
  eq #rvRenameCd([D,(T1',T2')],':=,Q?,C,C') = #rvRenameCd(D,C,C' /\ T1' := T2') .
  eq #rvRenameCd([D,(T1',T2')],'=>,Q?,C,C') = #rvRenameCd(D,C,C' /\ T1' => T2') .
endfm

fmod UNIFIERS is
  pr VARIABLES-TO-CONSTANTS .
  pr SUBSTITUTIONSET        .
  pr TERMSET-FM             .
  pr SUBSTITUTION-STREAM    .
  pr RENAME-TERM            .
  pr SUBSTITUTIONPAIRSET    .
  ---
  op  unifiers   : Module UnificationProblem                      -> SubstitutionSet .
  op #unifiers   : Module UnificationProblem Nat UnificationPair? -> Stream{Substitution} .
  ---
  op  matches    : Module Term Term                   -> SubstitutionSet .
  op #matches    : Module Term Term Nat Substitution? -> Stream{Substitution} .
  ---
  op  toUnifProb : NeTermSet      -> UnificationProblem .
  op  toUnifProb : Term NeTermSet -> UnificationProblem .

  var M    : Module .
  var UP   : UnificationProblem .
  var B : Bool .
  var Str : String .
  var I J X : Nat .
  var Bnd : Bound .
  var S S' S1 S2 : Substitution .
  var SS   : SubstitutionSet .
  var SPS : SubstitutionPairSet .
  var C : Constant .
  var V : Variable .
  var Q : Qid .
  var T T' : Term .
  var TL : TermList .
  var NTL : NeTermList .
  var TS : TermSet .
  var NTS  : NeTermSet .
  var SharedVars : VariableSet .

  --- PRE: Module well-defined; terms are well-defined in module
  --- OUT: The desired match number
  op metaMatch : Module Term Term Nat -> Substitution? .
  eq metaMatch(M,T,T',I) = if sameKind(M,leastSort(M,T),leastSort(M,T')) then metaMatch(M,T,T',nil,I) else noMatch fi .

  op metaMatch : Module Term Term -> Substitution? .
  eq metaMatch(M,T,T') = if sameKind(M,leastSort(M,T),leastSort(M,T')) then metaMatch(M,T,T',nil,0) else noMatch fi .

  --- INP: Module UnificationProblem
  --- PRE: Unification problem is well-formed in Module
  --- OUT: A complete set of unifiers
  --- NB:  #unifiers returns a stream of unifiers (useful for applications where the
  ---      process may take a long time)
  eq  unifiers(M,UP)             = set(#unifiers(M,UP,0,metaUnify(M,UP,0,0))) .
  eq #unifiers(M,UP,I,{S,J})     = S & #unifiers(M,UP,s(I),metaUnify(M,UP,s(J),s(I))) .
  eq #unifiers(M,UP,I,noUnifier) = end .

  --- INP: Module Term1 Term2
  --- PRE: Terms are well-formed in Module
  --- OUT: A complete set of matching substitutions from Term1 to Term2
  --- NB:  #matches returns a stream of matches (useful for applications where the
  ---      process may take a long time)
  eq  matches(M,T,T')            = set(#matches(M,T,T',0,metaMatch(M,T,T',nil,0))) .
  eq #matches(M,T,T',I,S)        = S & #matches(M,T,T',s(I),metaMatch(M,T,T',nil,s(I))) .
  eq #matches(M,T,T',I,noMatch)  = end .

  --- INP: NeTermSet
  --- PRE: NeTermSet has at least two elements
  --- OUT: A unification problem unifying all of the terms in the TermSet
  eq toUnifProb(T | NTS)         = toUnifProb(T,NTS) .
  eq toUnifProb(T,T' | NTS)      = T =? T' /\ toUnifProb(T,NTS) .
  eq toUnifProb(T,T')            = T =? T' .

  --- PRE: [1] Terms are well-defined in module
  ---      [2] Terms have disjoint variables, ignoring variables passed in as optional argument
  --- OUT: The standard unification/matching results
  op safeUnify : Module Term Term -> SubstitutionSet .
  op safeUnify : Module VariableSet Term Term -> SubstitutionSet .
 ceq safeUnify(M,SharedVars,T,T') = unifiers(M,T =? T') if intersection(vars(T),vars(T')) \ SharedVars == none .
  eq safeUnify(M,SharedVars,T,T') = errsub('Unification 'unexpected 'shared 'variable) [owise print "Safe Unify Variable Error"] .
  eq safeUnify(M,T,T')            = safeUnify(M,none,T,T') .

  op safeMatch : Module Term Term -> SubstitutionSet .
  op safeMatch : Module VariableSet Term Term -> SubstitutionSet .
 ceq safeMatch(M,SharedVars,T,T') = matches(M,T,T') if intersection(vars(T),vars(T')) \ SharedVars == none .
  eq safeMatch(M,SharedVars,T,T') = errsub('Match 'unexpected 'shared 'variable) [owise print "Safe Match Variable Error"] .
  eq safeMatch(M,T,T')            = safeMatch(M,none,T,T') .

  op safeMatch : Module Term Term Nat -> Substitution? .
  op safeMatch : Module VariableSet Term Term Nat -> Substitution? .
 ceq safeMatch(M,SharedVars,T,T',I) = metaMatch(M,T,T',I) if intersection(vars(T),vars(T')) \ SharedVars == none .
  eq safeMatch(M,SharedVars,T,T',I) = errsub('Match 'unexpected 'shared 'variable) [owise print "Safe Match Variable Error"] .
  eq safeMatch(M,T,T',I)            = safeMatch(M,none,T,T',I) .

  --- PRE: [1] Terms are well-defined in module
  ---      [2] Terms have no shared variables except for shared variables
  op sharedMatch : Module VariableSet Term Term -> SubstitutionSet .
  op sharedMatch : ModuleSubstPair Term Term -> SubstitutionSet .
 ceq sharedMatch(M,SharedVars,T,T') = sharedMatch(varsToConsts#(M,prefix,SharedVars),T,T') if intersection(vars(T),vars(T')) \ SharedVars == none .
  eq sharedMatch((M,S),T,T') = constsToVars(S,matches(M,T << S,T' << S)) .

  op matches? : Module Term Term -> Bool .
  eq matches?(M,T,T') = wellFormed(M,T) and-then wellFormed(M,T') and-then sameKind(M,leastSort(M,T),leastSort(M,T')) and-then metaMatch(M,T,T',nil,0) :: Substitution .

  op matchesX? : Module Term Term -> Bool .
  eq matchesX?(M,T,T') = matchesX?(M,T,T',0,unbounded) .

  op matchesX? : Module Term Term Nat Bound -> Bool .
  eq matchesX?(M,T,T',I,Bnd) = wellFormed(M,T) and-then wellFormed(M,T') and-then metaXmatch(M,T,T',nil,I,Bnd,0) :: MatchPair .

  op  nontrivCtxtMatch? : Module Term Term -> Bool .
  op $nontrivCtxtMatch? : Module Term Term Nat -> Bool .
  eq  nontrivCtxtMatch?(M,T,T')   = wellFormed(M,T) and-then wellFormed(M,T') and-then sameKind(M,leastSort(M,T),leastSort(M,T')) and-then $nontrivCtxtMatch?(M,T,T',0) .
  eq $nontrivCtxtMatch?(M,T,T',I) =
    metaXmatch(M,T,T',nil,0,unbounded,I) :: MatchPair and-then
   (getContext(metaXmatch(M,T,T',nil,0,unbounded,I)) =/= [] or-else $nontrivCtxtMatch?(M,T,T',s(I))) .

  op allUnifiers : Module Bool Term TermSet -> SubstitutionSet .
  eq allUnifiers(M,B,T,T' | TS) = if sameKind(M,leastSort(M,T),leastSort(M,T')) then disjUnifiersL(M,B,T,T') else empty fi | allUnifiers(M,B,T,TS) .
  eq allUnifiers(M,B,T,emptyTermSet) = empty .

  op  disjUnifiersL : Module Bool Term Term -> SubstitutionSet .
  op $disjUnifiersL : Module Bool RenamedTerm RenamedTerm -> SubstitutionSet .
  op $disjUnifiersL : Module Bool Substitution Nat UnificationProblem UnificationTriple SubstitutionSet -> SubstitutionSet .
  --------------------------------------------------------------------------------------------------------------------------
  eq  disjUnifiersL(M,B,T,T')                  = $disjUnifiersL(M,B,#renameVars(nullNameData,T),#renameVars(nullNameData,T')) .

  eq $disjUnifiersL(M,B,[[I,S],T],[[J,S'],T']) = $disjUnifiersL(M,B,S,0,T =? T',metaDisjointUnify2(M,B,T =? T',0),empty) .

  eq $disjUnifiersL(M,B,S2,I,UP,{S,S',J}, SS)  = $disjUnifiersL(M,B,S2,s(I),UP,metaDisjointUnify2(M,B,UP,s(I)),SS | renameDom(true,S,invert(S2))) .
  eq $disjUnifiersL(M,B,S2,I,UP,noUnifier,SS)  = SS .

  op  disjUnifiers : Module Bool Term Term -> SubstitutionPairSet .
  op $disjUnifiers : Module Bool RenamedTerm RenamedTerm -> SubstitutionPairSet .
  op $disjUnifiers : Module Bool Substitution Substitution Nat UnificationProblem UnificationTriple SubstitutionPairSet -> SubstitutionPairSet .
  ----------------------------------------------------------------------------------------------------------------------------------------------
  eq  disjUnifiers(M,B,T,T')                     = $disjUnifiers(M,B,#renameVars(nullNameData,T),#renameVars(nullNameData,T')) .

  eq $disjUnifiers(M,B,[[I,S],T],[[J,S'],T'])    = $disjUnifiers(M,B,S,S',0,T =? T',metaDisjointUnify2(M,B,T =? T',0),empty) .

  eq $disjUnifiers(M,B,S1,S2,I,UP,{S,S',J}, SPS) = $disjUnifiers(M,B,S1,S2,s(I),UP,metaDisjointUnify2(M,B,UP,s(I)),SPS | (renameDom(true,S,invert(S1)),renameDom(true,S',invert(S2)))) .
  eq $disjUnifiers(M,B,S1,S2,I,UP,noUnifier,SPS) = SPS .

  op metaDisjointUnify2 : Module Bool UnificationProblem Nat -> UnificationTriple .
  eq metaDisjointUnify2(M,true, UP,I) = metaVariantDisjointUnify(M,UP,empty,0,I) .
  eq metaDisjointUnify2(M,false,UP,I) = metaDisjointUnify(M,UP,0,I) .
endfm

fmod EQ-VARIANT is
  pr VARIANT .
  pr SUBSTITUTIONSET .

  --- sort to collect variant unifier results
  sort SubstSetNatPair .
  op  ssnp : SubstitutionSet Nat -> SubstSetNatPair [ctor] .

  --- copmute variants
  op  variants     : Module Term -> VariantTripleSet .
  op $variants     : Module Term Nat Variant? VariantTripleSet -> VariantTripleSet .
  --- compute variant unifiers
  op  var-unifiers : Module UnificationProblem -> SubstitutionSet .
  op #var-unifiers : Module UnificationProblem -> SubstSetNatPair .
  op $var-unifiers : Module UnificationProblem Nat Nat UnificationPair SubstitutionSet -> SubstSetNatPair .
  --- helper functions for variant/variant unifier generation
  op  applySubs : Variant SubstitutionSet -> VariantTripleSet .
  op  getSubs   : VariantTripleSet -> SubstitutionSet .
  op  getTerms  : VariantTripleSet -> TermSet .
  op  getss     : SubstSetNatPair -> SubstitutionSet .

  var M : Module . var T T' : Term . var I J J' : Nat . var P : Parent . var B : Bool .
  var S S' : Substitution . var SS : SubstitutionSet . var VS : VariantTripleSet . var UP : UnificationProblem .

  eq  variants(M,T)                       = $variants(M,T,0,metaGetVariant(M,T,empty,0,0),empty) .
  eq $variants(M,T,I,noVariant,VS)        = VS .
  eq $variants(M,T,I,{T',S,J,P,B},VS)     = $variants(M,T,s(I),metaGetVariant(M,T,empty,s(J),s(I)),{T',S,J,P,B} | VS) .
  eq  var-unifiers(M,UP)                  = getss(#var-unifiers(M,UP)) .
  eq #var-unifiers(M,UP)                  = $var-unifiers(M,UP,0,0,metaVariantUnify(M,UP,empty,0,0),empty) .
  eq $var-unifiers(M,UP,I,J,noUnifier,SS) = ssnp(SS,J) .
  eq $var-unifiers(M,UP,I,J,{S,J'},SS)    = $var-unifiers(M,UP,s(I),s(J'),metaVariantUnify(M,UP,empty,s(J'),s(I)),SS | S) .

  eq applySubs({T,S,I,P,B},S' | SS) = {T << S',S << S',I,P,B} | applySubs({T,S,I,P,B},SS) .
  eq applySubs({T,S,I,P,B},empty)   = empty .

  eq getSubs({T,S,I,P,B} | VS)  = S | getSubs(VS) .
  eq getSubs(empty)             = empty .
  eq getTerms({T,S,I,P,B} | VS) = T | getTerms(VS) .
  eq getTerms(empty)            = emptyTermSet .
  eq getss(ssnp(SS,I))          = SS .
endfm

fmod NARROWING is
  pr META-LEVEL .

  var M : Module .
  var S T : Term .
  var Rel : Qid .
  var Bnd : Bound .
  var VarFlag : Qid .
  var Num : Nat .
  var NSR : NarrowingSearchResult .
  var ResultSet : NarrowingSearchResultSet .

  var ResTerm : Term .
  var ResType : Type .
  var TermSub : Substitution .
  var TermVarFlag : Qid .
  var RuleSub : Substitution .
  var RuleVarFlag : Qid .

  sort NarrowingSearchResultSet .
  subsort NarrowingSearchResult? < NarrowingSearchResultSet .
  op _|_ : NarrowingSearchResultSet NarrowingSearchResultSet -> NarrowingSearchResultSet [ctor assoc comm id: .NarrowingSearchResultSet] .
  op .NarrowingSearchResultSet : -> NarrowingSearchResultSet [ctor] .

  op metaNarrowSearch : Module Term Term Qid Bound Qid -> NarrowingSearchResultSet .
  eq metaNarrowSearch(M,S,T,Rel,Bnd,VarFlag) =
     metaNarrowSearch(M,S,T,Rel,Bnd,VarFlag,0) .

  op metaNarrowSearch : Module Term Term Qid Bound Qid Nat -> NarrowingSearchResultSet .
  eq metaNarrowSearch(M,S,T,Rel,Bnd,VarFlag,Num) =
    metaNarrowSearch1(M,S,T,Rel,Bnd,VarFlag,Num,.NarrowingSearchResultSet,
      metaNarrowingSearch(M,S,T,Rel,Bnd,VarFlag,Num)) .

  op metaNarrowSearch1 : Module Term Term Qid Bound Qid Nat NarrowingSearchResultSet NarrowingSearchResult? -> NarrowingSearchResultSet .
  eq metaNarrowSearch1(M,S,T,Rel,Bnd,VarFlag,Num,ResultSet,failure)           = ResultSet .
  eq metaNarrowSearch1(M,S,T,Rel,Bnd,VarFlag,Num,ResultSet,failureIncomplete) = ResultSet | failureIncomplete .
  eq metaNarrowSearch1(M,S,T,Rel,Bnd,VarFlag,Num,ResultSet,NSR)               =
     metaNarrowSearch1(M,S,T,Rel,Bnd,VarFlag,s(Num),ResultSet | NSR,
       metaNarrowingSearch(M,S,T,Rel,Bnd,VarFlag,s(Num))) .

  --- For compatibility with older code
  sort ResultTripleSet .
  subsort ResultTriple < ResultTripleSet .
  op empty : -> ResultTripleSet [ctor] .
  op _|_ : ResultTripleSet ResultTripleSet -> ResultTripleSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
  eq X:ResultTriple | X:ResultTriple = X:ResultTriple .

  op toResultTripleSet : NarrowingSearchResultSet -> ResultTripleSet .
  eq toResultTripleSet({ ResTerm, ResType, TermSub, TermVarFlag, RuleSub, RuleVarFlag } | ResultSet) =
    { ResTerm, ResType, TermSub } | toResultTripleSet(ResultSet) .
  eq toResultTripleSet(.NarrowingSearchResultSet) = empty .
endfm

fmod METASEARCH is
  pr META-LEVEL .
  pr TERMSET-FM .
  pr NARROWING .

  var U : Module .
  var S T : Term .
  var C : Condition .
  var R : Qid .
  var B : Bound .
  var N : Nat .
  var RT : ResultTriple .
  var RTS : ResultTripleSet .
  var Sub : Substitution .
  var Ty : Type .

  op searchAll : Module Term -> ResultTripleSet .
  op searchAll : Module Term Qid -> ResultTripleSet .
  ---------------------------------------------------
  eq searchAll(U,S)   = searchAll(U,S,buildVar('X,getKind(U,leastSort(U,S))),nil,'*,unbounded) .
  eq searchAll(U,S,R) = searchAll(U,S,buildVar('X,getKind(U,leastSort(U,S))),nil,R ,unbounded) .

  op searchAll : Module Term Term Condition Qid Bound -> ResultTripleSet .
  op searchAll : Module Term Term Condition Qid Bound Nat ResultTriple ResultTripleSet -> ResultTripleSet .
  ---------------------------------------------------------------------------------------------------------
  eq searchAll(U,S,T,C,R,B) = searchAll(U,S,T,C,R,B,0,metaSearch(U,S,T,C,R,B,0),empty) .

  eq searchAll(U,S,T,C,R,B,N,RT,     RTS) = searchAll(U,S,T,C,R,B,s(N),metaSearch(U,S,T,C,R,B,s(N)),RTS | RT) .
  eq searchAll(U,S,T,C,R,B,N,failure,RTS) = RTS .

  op TermSet : ResultTripleSet -> TermSet .
  eq TermSet({T,Ty,Sub} | RTS)        = T | TermSet(RTS) .
  eq TermSet((empty).ResultTripleSet) = emptyTermSet .
endfm

fmod OP-FAMILY is
  pr TYPE-EXTRA .
  pr OPDECL-TYPING .

  sort OpFamily OpFamilyMap .
  subsort OpFamily < OpFamilyMap .
  op (_,_)|->_ : Qid TypeList OpDeclSet -> OpFamily [ctor] .
  op __ : OpFamilyMap OpFamilyMap -> OpFamilyMap [ctor assoc comm id: nil] .
  op nil : -> OpFamilyMap [ctor] .

  op getOpFamilies : Module Bool -> OpFamilyMap .
  op getOpFamilies : Module Bool OpDeclSet -> OpFamilyMap [memo] .
  op $opF : Module Bool OpDeclSet OpFamilyMap -> OpFamilyMap .

  var M : Module .
  var Q : Qid .
  var QS : QidSet .
  var TYL TYL' : TypeList .
  var TY : Type .
  var AS : AttrSet .
  var OS OS' : OpDeclSet .
  var OFM : OpFamilyMap .
  var OD : OpDecl .
  var B : Bool .

  --- INP: Module
  --- PRE: None
  --- OUT: OpFamilyMap which maps each Qid to all
  ---      the OpDecl's which have this Qid as their name
  eq getOpFamilies(M,B) = getOpFamilies(M,B,getOps(M)) .
  eq getOpFamilies(M,B,OS) = $opF(M,B,OS,nil) .
 ceq $opF(M,B,op Q : TYL -> TY [AS]. OS,OFM (Q,TYL') |-> OS') = $opF(M,B,OS,OFM (Q,TYL') |-> OS' op Q : TYL -> TY [AS].)
  if TYL' == toKind(M,TYL if B then TY else nil fi) .
  eq $opF(M,B,OD OS, OFM) = $opF(M,B,OS,OFM (qid(OD),toKind(M,argTypes(OD) if B then resultType(OD) else nil fi)) |-> OD) [owise] .
  eq $opF(M,B,none,OFM) = OFM .

  --- INP: OpFamilyMap
  --- PRE: OpFamilyMap is well-formed and sensible
  --- OUT: if Bool is true,  true iff operators are adhoc-overloaded
  ---      if Bool is false, true iff operators with same # of args are adhoc-overloaded
  op adhoc-overloaded? : OpFamilyMap Bool -> Bool .
  eq adhoc-overloaded?(OFM,B) = adhoc-overloaded(OFM,B,none) =/= none .

  op adhoc-overloaded : OpFamilyMap Bool QidSet -> QidSet .
 ceq adhoc-overloaded(((Q,TYL) |-> OS) ((Q,TYL') |-> OS') OFM,B,QS) =
    adhoc-overloaded(((Q,TYL) |-> OS) OFM,B,QS ; Q)
  if TYL =/= TYL' and-then (B or-else size(TYL) == size(TYL')) .
  eq adhoc-overloaded(OFM,B,QS) = QS [owise] .

  op flattenOpFamily : OpFamilyMap -> OpDeclSet .
  eq flattenOpFamily(((Q,TYL') |-> OD OS) OFM) = OD flattenOpFamily(OFM) .
  eq flattenOpFamily(nil) = none .
endfm

fmod OP-FAMILY-AUX is
  pr OP-FAMILY .

  op ctorsPreregularBelow : Module -> Bool .
  op ctorsPreregularBelow : Module OpFamilyMap -> Bool .
  op $ctorsPreregularBelow : Module TypeListSet OpDeclSet OpDeclSet -> Bool .
  op $ctorsPreregularBelow1 : Module TypeList OpDeclSet OpDeclSet -> Bool .
  op typesBelowMaximalOps : Module OpDeclSet -> TypeListSet .

  var M : Module .
  var Q : Qid .
  var TYL TYL' KL : TypeList .
  var TY TY' : Type .
  var AS AS' : AttrSet .
  var OS OS' OS'' : OpDeclSet .
  var OFM : OpFamilyMap .
  var OD : OpDecl .
  var TYLS : TypeListSet .

  eq typesBelowMaximalOps(M,OD OS) = typesBelow(M,argTypes(OD)) ; typesBelowMaximalOps(M,OS) .
  eq typesBelowMaximalOps(M,none) =  none .

  --- INP: OpFamilyMap
  --- PRE: Valid OpFamilyMap
  --- OUT: true iff ctors always have minimal typings
  eq ctorsPreregularBelow(M) = ctorsPreregularBelow(M,getOpFamilies(M,false)) .
  eq ctorsPreregularBelow(M,OFM (Q,KL) |-> OS) =
   $ctorsPreregularBelow(M,typesBelowMaximalOps(M,OS),ctors(OS),OS - ctors(OS)) and-then
   ctorsPreregularBelow(M,OFM) .
  eq ctorsPreregularBelow(M,nil) = true .

  eq $ctorsPreregularBelow(M,TYL ; TYLS,OS,OS') =
     $ctorsPreregularBelow1(M,TYL,OS,OS') and-then
     $ctorsPreregularBelow(M,TYLS,OS,OS') .
  eq $ctorsPreregularBelow(M,none,OS,OS') = true .

  --- NOTE: if the opsAbove intersect?s with the ctors, then the minimum
  ---       must be a ctor; if there is no minimum, we violated preregularity
  ceq $ctorsPreregularBelow1(M,TYL,OS,OS') = intersect?(OS,OS'') implies OD inODS OS
  if OS'' := opsAbove(M,TYL,OS OS') /\
     OD   := getMinimal(M,OS'') .
  eq $ctorsPreregularBelow1(M,TYL,OS,OS') = false [owise] .

  --- INP: OpFamilyMap
  --- PRE: Valid OpFamilyMap
  --- OUT: true iff no ops have the same input sorts and different output sorts
  op sameArgsDiffRes : OpFamilyMap -> Bool .
 ceq sameArgsDiffRes(OFM (Q,KL) |-> OS op Q : TYL -> TY [AS]. op Q : TYL -> TY' [AS'].) = true if TY == TY' .
  eq sameArgsDiffRes(OFM) = false [owise] .
endfm

fmod EQ-FAMILY is
  pr OP-FAMILY .
  pr UNIFIERS .

  var M : Module .
  var B : Bool .
  var Q : Qid .
  var QL : QidList .
  var NTYL : NeTypeList .
  var TYL : TypeList .
  var TY : Type .
  var T : Term .
  var O : OpDecl .
  var OS OS' : OpDeclSet .
  var OFM CFM : OpFamilyMap .
  var E : Equation .
  var ES : EquationSet .
  var EFM EFM' : EqFamilyMap .

  sort EqFamily EqFamilyMap .
  subsort EqFamily < EqFamilyMap .
  op (_,_)|->_ : Qid TypeList EquationSet -> EqFamily [ctor] .
  op __ : EqFamilyMap EqFamilyMap -> EqFamilyMap [ctor assoc comm id: nil] .
  op nil : -> EqFamilyMap [ctor] .

  --- Constructors
  op getEqFamilies : Module ~> EqFamilyMap .
  eq getEqFamilies(M) = getEqFamilies(setOps(M,removeIdAttrs(getOps(M))),splitConsts(getOps(M))) .

  op getEqFamilies : Module OpDeclSetPair ~> EqFamilyMap .
  eq getEqFamilies(M,(OS,OS')) = getEqFamilies(M,getOpFamilies(M,true,OS),getOpFamilies(M,false,OS'),getEqs(M),nil) .

  op getEqFamilies : Module OpFamilyMap OpFamilyMap EquationSet EqFamilyMap ~> EqFamilyMap .
  eq getEqFamilies(M,CFM,OFM,E ES,EFM) = getEqFamilies(M,CFM,OFM,ES,$eqF($topOperator(M,lhs(E),CFM,OFM),E,EFM)) .
  eq getEqFamilies(M,CFM,OFM,none,EFM) = EFM .

  --- Selectors
  op getEqFamilies : Module EqFamilyMap OpDeclSet -> EqFamilyMap .
  op getEqFamilies : Module EqFamilyMap OpDeclSet EqFamilyMap -> EqFamilyMap .
  ----------------------------------------------------------------------------
  eq getEqFamilies(M,EFM,OS)        = getEqFamilies(M,EFM,OS,nil) .
  eq getEqFamilies(M,EFM,O OS,EFM') = getEqFamilies(M,EFM,OS,EFM' getEqFamily$(EFM,qid(O) toKind(M,argTypes(O)))) .
  eq getEqFamilies(M,EFM,none,EFM') = EFM' .

  op getEqFamily  : Module EqFamilyMap QidList ~> EqFamilyMap .
  op getEqFamily$ : EqFamilyMap QidList ~> EqFamilyMap .
  ------------------------------------------------------
  eq getEqFamily (M,EFM,Q TYL) = getEqFamily$(EFM,Q toKind(M,TYL)) .

  eq getEqFamily$(((Q,TYL) |-> ES) EFM,Q TYL) = (Q,TYL) |-> ES .
  eq getEqFamily$(                 EFM,Q TYL) = nil [owise] .

  --- Auxiliary
  op $eqF : NeQidList Equation EqFamilyMap ~> EqFamilyMap .
  eq $eqF(Q TYL,E,((Q,TYL) |-> ES) EFM) = ((Q,TYL) |-> E ES) EFM .
  eq $eqF(Q TYL,E,EFM)                  = ((Q,TYL) |-> E)    EFM [owise] .

  op $topOperator : Module Term OpFamilyMap OpFamilyMap -> QidList .
  eq $topOperator(M,T,CFM,OFM) =
    if $topOperator(M,true,T,CFM) :: NeQidList
      then $topOperator(M,true,T,CFM)
      else $topOperator(M,false,T,OFM)
    fi .

  --- Return the operator type that matches this one at the top
  --- NOTE: there should always be one --- otherwise it is an error
  op $topOperator : Module Bool Term OpFamilyMap -> QidList .
  eq $topOperator(M,false,T,((Q,TYL) |-> OS) OFM) =
    if matches?(M,buildTerm(Q,0,TYL,'Unused),T)
      then Q TYL
      else $topOperator(M,false,T,OFM)
    fi .
  eq $topOperator(M,true,T,((Q,TY) |-> OS) CFM) =
    if matches?(M,buildTerm(Q,0,nil,TY),T)
      then Q
      else $topOperator(M,true,T,CFM)
    fi .
  eq $topOperator(M,B,T,nil) = nil .
endfm

fmod DECL-SUBSUMPTION is
  pr UNIT-FM .
  pr STMT-EXTRA .

  var M M' : Module .
  var Eq Eq' : Equation .
  var EqS EqS' : EquationSet .
  var Rl Rl' : Rule .
  var RlS RlS' : RuleSet .
  var T T' T1 T1' : Term .
  var Cond : Condition .
  var Cond1 : EqCondition .
  var S : Sort .
  var SS : SortSet .
  var AtS : AttrSet .
  var MbS : MembAxSet .


  *** moreGeneralEqs/Rls ******************************
  ---- An equation/rule is more general than other if there is a substitution
  ---- such that the more general equation with such a substitution applied is
  ---- equal to the less general one.

  --- OUT: keep only most general equations/rules in the module
  op moreGeneralEqs : Module -> Module .
  op moreGeneralRls : Module -> Module .
  eq moreGeneralEqs(M) = setEqs(M,moreGeneralEqs(M,getEqs(M))) .
  eq moreGeneralRls(M) = setRls(M,moreGeneralRls(M,getRls(M))) .

  --- OUT: return the most general equations/rules from the equation/ruleset
  op moreGeneralEqs : Module EquationSet -> EquationSet .
  op moreGeneralRls : Module RuleSet -> RuleSet .
  eq moreGeneralEqs(M,EqS) = $moreGeneralEqs(M,$mgdMod(M),EqS,EqS) .
  eq moreGeneralRls(M,RlS) = $moreGeneralRls(M,$mgdMod(M),RlS,RlS) .

  op $moreGeneralEqs : Module Module EquationSet EquationSet -> EquationSet .
  op $moreGeneralRls : Module Module RuleSet RuleSet -> RuleSet .
  eq $moreGeneralEqs(M,M',Eq EqS,EqS') = $moreGeneralEqs(M,M',EqS,Eq $remLessGenEqs(M',$mgdTerm(Eq),EqS',none)) .
  eq $moreGeneralEqs(M,M',none,EqS') = EqS' .
  eq $moreGeneralRls(M,M',Rl RlS,RlS') = $moreGeneralRls(M,M',RlS,Rl $remLessGenRls(M',$mgdTerm(Rl),RlS',none)) .
  eq $moreGeneralRls(M,M',none,RlS') = RlS' .

  --- OUT: return the set of equations/rules that are not matched by the term
  op $remLessGenEqs : Module Term EquationSet EquationSet -> EquationSet .
  op $remLessGenRls : Module Term RuleSet RuleSet -> RuleSet .
  eq $remLessGenEqs(M',T,Eq EqS,EqS') =
    if metaMatch(M',T,$mgdTerm(Eq),nil,0) :: Substitution
      then $remLessGenEqs(M',T,EqS,EqS')
      else $remLessGenEqs(M',T,EqS,Eq EqS')
    fi .
  eq $remLessGenEqs(M',T,none,EqS') = EqS' .
  eq $remLessGenRls(M',T,Rl RlS,RlS') =
    if metaMatch(M',T,$mgdTerm(Rl),nil,0) :: Substitution
      then $remLessGenRls(M',T,RlS,RlS')
      else $remLessGenRls(M',T,RlS,Rl RlS')
    fi .
  eq $remLessGenRls(M',T,none,RlS') = RlS' .

  --- OUT: an enrichment of the module with a sort called @@@
  --- that contains isomorphic representations of equations and rules
  op $mgdMod : Module -> Module [memo] .
  eq $mgdMod(M) =
    addOps((op '@nil@ : nil -> '@@@ [none] .
            op '@/\@  : '@@@ '@@@ -> '@@@ [assoc comm id('@nil@.@@@)] .
            op '@:@   : '@@@ '@@@ -> '@@@ [assoc] .
            op '@--@  : 'Universal 'Universal -> '@@@ [poly(1 2)] .
            $mgdAddSortConsts(getSorts(M))),addSorts('@@@, M)) .

  --- OUT: a set of fresh operators declarations corresponding to each sort
  op $mgdAddSortConsts : SortSet -> OpDeclSet .
  eq $mgdAddSortConsts(S ; SS) =
    (op qid("@@@" + string(S) + "@@@") : nil -> '@@@ [none].)
    $mgdAddSortConsts(SS) .
  eq $mgdAddSortConsts(none) = none .

  --- OUT: a term in sort @@@ that represents an equation or rule declaration
  op $mgdTerm : Equation -> Term [memo] .
  op $mgdTerm : Rule -> Term [memo] .
  eq $mgdTerm(Eq) = $mgdTerm(cond(Eq),'@--@[lhs(Eq),rhs(Eq)]) .
  eq $mgdTerm(Rl) = $mgdTerm(cond(Rl),'@--@[lhs(Rl),rhs(Rl)]) .

  op $mgdTerm : Condition Term -> Term .
  eq $mgdTerm(T1 = T1'  /\ Cond1, T) = $mgdTerm(Cond1, '@:@['@--@[T1, T1'], T]) .
  eq $mgdTerm(T1 := T1' /\ Cond1, T) = $mgdTerm(Cond1, '@:@['@--@[T1, T1'], T]) .
  eq $mgdTerm(T1 => T1' /\ Cond1, T) = $mgdTerm(Cond1, '@:@['@--@[T1, T1'], T]) .
  eq $mgdTerm(T1 : S    /\ Cond1, T) = $mgdTerm(Cond1, '@:@['@--@[T1, $mgdSortConst(S)], T]) .
  eq $mgdTerm(nil,                T) = T .

  op $mgdSortConst : Sort -> Term .
  eq $mgdSortConst(S) = qid("@@@" + string(S) + "@@@.@@@") .

  op rmVariantAttrs : Module -> Module .
  op $rmVariants : EquationSet -> EquationSet .
  op $rmVariants : RuleSet -> RuleSet .
  op $rmVariants : MembAxSet -> MembAxSet .
  eq rmVariantAttrs(M) = setRls(setEqs(setMbs(M, $rmVariants(getMbs(M))), $rmVariants(getEqs(M))), $rmVariants(getRls(M))) .

  eq $rmVariants(eq T = T' [variant AtS] . EqS) = (eq T = T' [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(ceq T = T' if Cond [variant AtS] . EqS) = (ceq T = T' if Cond [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(EqS) = EqS [owise] .

  eq $rmVariants(rl T => T' [variant AtS] . RlS) = (rl T => T' [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(crl T => T' if Cond [variant AtS] . RlS) = (crl T => T' if Cond [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(RlS) = RlS [owise] .

  eq $rmVariants(mb T : S [variant AtS] . MbS) = (mb T : S [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(cmb T : S if Cond [variant AtS] . MbS) = (cmb T : S if Cond [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(MbS) = MbS [owise] .
endfm

fmod REMOVE-IDS is
  pr UNIT-FM .
  pr OP-FAMILY .
  pr EQ-VARIANT .
  pr ATTR-EXTRA .
  pr DECL-SUBSUMPTION .
  pr STMT-EXTRA .
  pr RENAME-TERM-AUX .

  var C : Constant .
  var M M' IdM : Module .
  var I J N : Nat .
  var T T' T'' L R : Term .
  var F : Qid .
  var TL : TermList .
  var AtS : AttrSet .
  var VtS : VariantTripleSet .
  var Tp Tp' Tp'' : Type .
  var TpL : TypeList .
  var Rl : Rule .
  var RlS : RuleSet .
  var Eq : Equation .
  var EqS : EquationSet .
  var ODS : OpDeclSet .
  var Cond : Condition .
  var S : Sort .
  var Subst Subst' : Substitution .
  var SubstS SubstS' : SubstitutionSet .
  var Str : String .
  var Which : IdsToRemove .
  var Subsumption? : Bool .

  sort IdsToRemove .
  ops all non-handled : -> IdsToRemove .

  op removeIds  : Module IdsToRemove ~> Module .
  op removeIds  : Module Bool IdsToRemove ~> Module [memo] .
  op $removeIds : Module Bool IdsToRemove ~> Module .
  op $removeIds : Module IdsToRemove ~> Module .

  --- TODO: Reorganize these so they return an intermediate data structure which maps
  ---       an equation/rule to the set of its variants
  ---       Such a data structure will enable analysis of the generated theories
  op getVariants : Module Module Module RuleSet -> RuleSet .
  op getVariants : Module Module Module EquationSet -> EquationSet .
  op getRlVariants : Module Module VariantTripleSet Term Condition AttrSet RuleSet -> RuleSet .
  op getEqVariants : Module Module VariantTripleSet Term Condition AttrSet EquationSet -> EquationSet .

  eq removeIds(M, Which) = removeIds(M, true, Which) .
 ceq removeIds(M, Subsumption?, Which) =
   if (Which == all         and not id-ops?(getOps(M))) or-else
      (Which == non-handled and not au-ops?(getOps(M)))
     then M
     else $removeIds(M, Subsumption?, Which)
   fi
  if not (anyAttrOccurs?(owise idem,getOps(M)) or-else anyLhsIsVar?(getRls(M)) or-else anyLhsIsVar?(getEqs(M))) .

  eq $removeIds(M, true,  Which) = renameVars(moreGeneralRls(moreGeneralEqs($removeIds(M, Which)))) .
  eq $removeIds(M, false, Which) = renameVars($removeIds(M, Which)) .
  eq $removeIds(M, Which) = setRls(
                              addEqs(getVariants(makeIdsModule(M,Which),makeIdsTuplingModule(M, Which), addTupling(M, M), getEqs(M)),
                                makeIdsModule(M, Which)),
                              getVariants(makeIdsModule(M,Which),makeIdsTuplingModule(M, Which), addTupling(M, M), getRls(M))) .

  eq getVariants(IdM, M, M', Rl RlS)
    = getRlVariants(IdM, M', variants(M, makeTuple(lhs(Rl), cond(Rl))), rhs(Rl), cond(Rl), attrSet(Rl), none)
      getVariants(IdM, M, M', RlS) .
  eq getVariants(IdM, M, M', (none).RuleSet) = none .

  eq getVariants(IdM, M, M', Eq EqS)
    = getEqVariants(IdM, M', variants(M, makeTuple(lhs(Eq), cond(Eq))), rhs(Eq), cond(Eq), attrSet(Eq), none)
      getVariants(IdM, M, M', EqS) .
  eq getVariants(IdM, M, M', (none).EquationSet) = none .

  eq getRlVariants(IdM, M, ({'@<@_@>@[T], Subst, N, P:Parent,B:Bool} | VtS), T', nil, AtS, RlS)
    = getRlVariants(IdM, M, VtS, T', nil, AtS, RlS
        (rl getTerm(metaNormalize(M, T)) => getTerm(metaNormalize(M, _<<_(getTerm(metaNormalize(M,T')), Subst))) [AtS] .)
      ) .
  eq getRlVariants(IdM, M, ({F[T, TL], Subst,N,P:Parent,B:Bool} | VtS), T', Cond, AtS, RlS)
    = getRlVariants(IdM, M, VtS, T', Cond, AtS, RlS
        (crl getTerm(metaNormalize(M, T)) => getTerm(metaNormalize(M, _<<_(getTerm(metaNormalize(M,T')), Subst))) if makeCond(TL, Cond, Subst) [AtS] .)
      ) .
  eq getRlVariants(IdM, M, empty, T', Cond, AtS, RlS) = moreGeneralRls(IdM,RlS) .

  eq getEqVariants(IdM, M, ({'@<@_@>@[T], Subst, N,P:Parent,B:Bool} | VtS), T', nil, AtS, EqS)
    = getEqVariants(IdM, M, VtS, T', nil, AtS, EqS
        (eq getTerm(metaNormalize(M, T)) = getTerm(metaNormalize(M, _<<_(getTerm(metaNormalize(M,T')), Subst))) [AtS] .)
      ) .
  eq getEqVariants(IdM, M, ({F[T, TL], Subst, N,P:Parent,B:Bool} | VtS), T', Cond, AtS, EqS)
    = getEqVariants(IdM, M, VtS, T', Cond, AtS, EqS
        (ceq getTerm(metaNormalize(M, T)) = getTerm(metaNormalize(M, _<<_(getTerm(metaNormalize(M,T')), Subst))) if makeCond(TL, Cond, Subst) [AtS] .)
      ) .
  eq getEqVariants(IdM, M, empty, T', Cond, AtS, EqS) = moreGeneralEqs(IdM,EqS) .

  ------------------------------------------------------------------------------
  --- TODO: Figure out how/if the tupling module can be simplified
  ---       and made robust to weirdly named operators

  op makeIdsTuplingModule : Module IdsToRemove -> Module .
  eq makeIdsTuplingModule(M, Which) = addTupling(M, makeIdsModule(M, Which)) .

  op makeIdsModule : Module IdsToRemove -> Module .
  eq makeIdsModule(M, Which)
    = setEqs(
        setOps(
          setRls(M, none),
          removeIds(M,getOps(M),Which)),
        idEqs(M, 0, flattenOpFamily(getOpFamilies(M,false,getOps(M))), Which)) .

  op addTupling : Module Module -> Module .
  eq addTupling(M, M')
    = addOps(
        tuplingOps(M, getEqs(M), getRls(M)),
        addSorts('Tuple, M')) .

  op tuplingOps : Module EquationSet RuleSet -> OpDeclSet .
  op tuplingOps : Module EquationSet -> OpDeclSet .
  op tuplingOps : Module RuleSet -> OpDeclSet .
  eq tuplingOps(M, EqS, RlS) = tuplingOps(M, EqS) tuplingOps(M, RlS) .
  eq tuplingOps(M, eq L = R [AtS] . EqS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, L)) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, ceq L = R if Cond [AtS] . EqS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, L)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, (none).EquationSet) = none .
  eq tuplingOps(M, rl L => R [AtS] . RlS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, L)) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, crl L => R if Cond [AtS] . RlS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, L)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, (none).RuleSet) = none .

  op arityCond : Module Condition -> TypeList .
  eq arityCond(M, T => T' /\ Cond) = getKind(M, leastSort(M, T')) arityCond(M, Cond) .
  eq arityCond(M, T := T' /\ Cond) = getKind(M, leastSort(M, T)) arityCond(M, Cond) .
  eq arityCond(M, T = T' /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, T : S /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, nil) = nil .

  op tupleId : Condition -> String .
  eq tupleId(T => T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T := T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T = T' /\ Cond) = tupleId(Cond) .
  eq tupleId(T : S /\ Cond) = tupleId(Cond) .
  eq tupleId(Cond) = "" .

  ------------------------------------------------------------------------------

  op makeTuple : Term Condition -> Term .
  eq makeTuple(T, Cond)
    = if Cond == nil
      then qid("@<@_@>@")[T]
      else qid("@<@_" + tupleId(Cond) + "@>@")[T, tupleTermList(Cond)]
      fi .

  op tupleTermList : Condition -> TermList .
  eq tupleTermList(T' => T'' /\ Cond) = (T'', tupleTermList(Cond)) .
  eq tupleTermList(T' = T'' /\ Cond) = tupleTermList(Cond) .
  eq tupleTermList(T' : S /\ Cond) = tupleTermList(Cond) .
  eq tupleTermList(T' := T'' /\ Cond) = (T', tupleTermList(Cond)) .
  eq tupleTermList(nil) = empty .

  op makeCond : TermList Condition Substitution -> Condition .
  eq makeCond((T, TL), T' => T'' /\ Cond, Subst)
    = (T' << Subst) => T /\ makeCond(TL, Cond, Subst) .
  eq makeCond((T, TL), T' := T'' /\ Cond, Subst)
    = T := (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' = T'' /\ Cond, Subst)
    = (T' << Subst) = (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' : S /\ Cond, Subst)
    = (T' << Subst) : S /\ makeCond(TL, Cond, Subst) .
  eq makeCond(empty, nil, Subst) = nil .

  ------------------------------------------------------------------------------

  op idEqs : Module Nat OpDeclSet IdsToRemove -> EquationSet .
  eq idEqs(M, N, op F : Tp Tp' -> Tp'' [left-id(T) AtS] . ODS, Which)
    = (eq F[T, qid(idEqVarName("X",N) + string(getKind(M, Tp)))] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id")] .)
      if in(assoc,AtS) and not in(comm,AtS)
      then (eq F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), F[T, qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]]
              = F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
              [variant metadata("id")] .)
      else none
      fi
      idEqs(M, s(N), ODS, Which) .
  eq idEqs(M, N, op F : Tp Tp' -> Tp'' [right-id(T) AtS] . ODS, Which)
    = (eq F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), T] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id")] .)
      if in(assoc,AtS) and not in(comm,AtS)
      then (eq F[F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), T], qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
              = F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
              [variant metadata("id")] .)
      else none
      fi
      idEqs(M, s(N), ODS, Which) .
  eq idEqs(M, N, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, all)
    = if in(comm,AtS)
      then (eq F[T, qid(idEqVarName("X",N) + string(getKind(M, Tp)))] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id")] .)
      else (eq F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), T] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id")] .)
           (eq F[T, qid(idEqVarName("X",N) + string(getKind(M, Tp)))] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id")] .)
      fi
      if in(assoc,AtS) and not in(comm,AtS)
      then (eq F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), F[T, qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]]
              = F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
              [variant metadata("id")] .)
           (eq F[F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), T], qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
              = F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
              [variant metadata("id")] .)
      else none
      fi
      idEqs(M, s(N), ODS, all) .
  eq idEqs(M, N, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, non-handled)
    = if in(assoc,AtS) and in(comm,AtS)
      then none
      else if in(comm,AtS)
           then (eq F[T, qid(idEqVarName("X",N) + string(getKind(M, Tp)))] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id")] .)
           else (eq F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), T] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id")] .)
                (eq F[T, qid(idEqVarName("X",N) + string(getKind(M, Tp)))] = qid(idEqVarName("X",N) + string(getKind(M, Tp))) [variant metadata("id") ] .)
           fi
           if in(assoc,AtS) and not in(comm,AtS)
           then (eq F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), F[T, qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]]
                   = F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
                   [variant metadata("id")] .)
                (eq F[F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), T], qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
                   = F[qid(idEqVarName("X",N) + string(getKind(M, Tp))), qid(idEqVarName("Y",N) + string(getKind(M, Tp)))]
                   [variant metadata("id")] .)
           else none
           fi
      fi
      idEqs(M, s(N), ODS, non-handled) .
  eq idEqs(M, N, ODS, Which) = none [owise] .

  op idEqVarName : String Nat -> String .
  eq idEqVarName(Str,N) = Str + string(N,10) + ":" .

  ------------------------------------------------------------------------------

  op removeIds : Module OpDeclSet IdsToRemove -> OpDeclSet .
  eq removeIds(M,op F : TpL -> Tp [id(T) AtS] . ODS, all)
    = removeIds(M,op F : TpL -> Tp [addIdMetadata(M,T,AtS)] . ODS, all) .
 ceq removeIds(M,op F : TpL -> Tp [id(T) AtS] . ODS, non-handled)
    = removeIds(M,op F : TpL -> Tp [addIdMetadata(M,T,AtS)] . ODS, non-handled)
    if not in(assoc comm,AtS) .
  eq removeIds(M,op F : TpL -> Tp [left-id(T) AtS] . ODS, Which)
    = removeIds(M,op F : TpL -> Tp [addIdMetadata(M,T,AtS)] . ODS, Which) .
  eq removeIds(M,op F : TpL -> Tp [right-id(T) AtS] . ODS, Which)
    = removeIds(M,op F : TpL -> Tp [addIdMetadata(M,T,AtS)] . ODS, Which) .
  eq removeIds(M,ODS, Which) = ODS [owise] .

  --- NB: this returns an error if the id element is not a constant
  op addIdMetadata : Module Term AttrSet ~> AttrSet .
  eq addIdMetadata(M,C,metadata(Str) AtS) = metadata(Str + " ID " + string(getName(C)) + "." + string(leastSort(M,C))) AtS .
  eq addIdMetadata(M,C,AtS) = metadata(string(C)) AtS [owise] .

  op deleteIdEqs : Module -> Module .
  eq deleteIdEqs(M) = setEqs(M,nonIdEqs(getEqs(M))) .

  op nonIdEqs : EquationSet -> EquationSet .
  eq nonIdEqs(Eq EqS) = if metadata(Eq) == "id" then nonIdEqs(EqS) else Eq nonIdEqs(EqS) fi .
  eq nonIdEqs(none) = none .
endfm

fmod REMOVE-COMM is
  pr UNIT-FM .
  pr TERMSET-FM .
  pr TERM-EXTRA .
  pr STMT-EXTRA .
  pr OPDECLSET-EXTRA .
  pr METASEARCH .

  var U : Module .
  var Q  : Qid .
  var YL : TypeList .
  var Y1 Y2 Y3 Y : Type .
  var AS : AttrSet .
  var ODS : OpDeclSet .
  var T L R : Term .
  var TS : TermSet .
  var Rl : Rule .
  var RlS : RuleSet .
  var Eq : Equation .
  var EqS : EquationSet .

  --- Entry points
  op removeComm : Module -> Module [memo] .
  op removeComm : Module Term -> TermSet .
  ----------------------------------------
  eq removeComm(U) =
    setRls(
      setEqs(
        setOps(U,removeComm(getOps(U))),
        removeComm$(commRuleModule(U),getEqs(U))),
      removeComm$(commRuleModule(U),getRls(U))) .

  eq removeComm(U,T) = TermSet(searchAll(commRuleModule(U),T)) .

  --- Iterate over rules/equations and transform them
  op removeComm$ : Module RuleSet -> RuleSet .
  op removeComm$ : Module EquationSet -> EquationSet .
  ----------------------------------------------------
  eq removeComm$(U,Rl RlS) =
    removeComm$(Rl,TermSet(searchAll(U,lhs(Rl)))) removeComm$(U,RlS) .
  eq removeComm$(U,(none).RuleSet) = none .

  eq removeComm$(U,Eq EqS) =
    removeComm$(Eq,TermSet(searchAll(U,lhs(Eq)))) removeComm$(U,EqS) .
  eq removeComm$(U,(none).EquationSet) = none .

  op removeComm$ : Rule TermSet  -> RuleSet .
  op removeComm$ : Equation TermSet -> EquationSet .
  --------------------------------------------------
  eq removeComm$(Rl,T | TS)       = set-lhs(Rl,T) removeComm$(Rl,TS) .
  eq removeComm$(Rl,emptyTermSet) = (none).RuleSet .

  eq removeComm$(Eq,T | TS)       = set-lhs(Eq,T) removeComm$(Eq,TS) .
  eq removeComm$(Eq,emptyTermSet) = (none).EquationSet .

  --- Create module which we will use to explore commutative equivalence classes
  op commRuleModule : Module -> Module [memo] .
  ---------------------------------------------
  eq commRuleModule(U) = setRls(setEqs(setOps(U,removeComm(getOps(U))),none),commRules(U,getOps(U))) .

  op commRules : Module OpDeclSet ~> RuleSet .
  --------------------------------------------
  eq commRules(U,op Q : Y1 Y2 -> Y [AS]. ODS) =
    if in(comm,AS) and not in(assoc,AS)
       then if sameKind(U,Y1,Y2)
         then (rl Q[buildVar('L,getKind(U,Y1)),buildVar('R,getKind(U,Y1))] => Q[buildVar('R,getKind(U,Y1)),buildVar('L,getKind(U,Y1))] [none].)
         else (rl Q[buildVar('L,getKind(U,Y1)),buildVar('R,getKind(U,Y2))] => Q[buildVar('R,getKind(U,Y2)),buildVar('L,getKind(U,Y1))] [none].
               rl Q[buildVar('L,getKind(U,Y2)),buildVar('R,getKind(U,Y1))] => Q[buildVar('R,getKind(U,Y1)),buildVar('L,getKind(U,Y2))] [none].)
         fi
       else none
    fi commRules(U,ODS) .
  eq commRules(U,op Q : nil         -> Y [AS]. ODS) = commRules(U,ODS) .
  eq commRules(U,op Q : Y1          -> Y [AS]. ODS) = commRules(U,ODS) .
  eq commRules(U,op Q : Y1 Y2 Y3 YL -> Y [AS]. ODS) = commRules(U,ODS) .
  eq commRules(U,none)                              = none .
endfm

fmod SHOW-VARIANTS is
  pr META-LEVEL .
  pr VARIANT * (op addOps to MHaddOps, op addEqs to MHaddEqs, op addSorts to MHaddSorts) .

  ---(
  sort VariantSet .
  subsort Variant < VariantSet .
  op _|_ : VariantSet VariantSet -> VariantSet [ctor assoc comm id: mt] .
  op mt  : -> VariantSet [ctor] .
  ---)

  op showVariants : Module Term Bound -> VariantTripleSet .
  op showVariants : Module Term Bound Nat Variant? -> VariantTripleSet .
  op showVariant  : Variant -> Variant .

  var N : Nat .
  var M : Module .
  var T : Term .
  var TOT : Bound .
  var V : Variant .
  var P : Parent .
  var B : Bool .
  var S : Substitution .

  eq showVariants(M,T,TOT)                       = showVariants(M,T,TOT,0,metaGetVariant(M,T,empty,0,0)) .
  eq showVariants(M,T,s(TOT),N,V)                = showVariant(V) | showVariants(M,T,TOT,s(N),metaGetVariant(M,T,empty,0,s(N))) .
  eq showVariants(M,T,unbounded,N,V)             = showVariant(V) | showVariants(M,T,unbounded,s(N),metaGetVariant(M,T,empty,0,s(N))) .
  eq showVariants(M,T,0,N,V)                     = showVariant(V) .
  eq showVariants(M,T,TOT,N,noVariant)           = empty .
  eq showVariants(M,T,TOT,N,noVariantIncomplete) = empty .
  eq showVariant({T,S,N,P,B})                    = {T,S,N,P,B} [print "VARIANT: {" T "," S "}"] .
endfm
