--- file: prelude-aux.maude
--- reqs: prelude
--- desc: This file extends the basic datatypes in the prelude
---       with many additional operations

fmod MAYBE-QID is
  pr QID .
  sort MaybeQid .
  subsort Qid < MaybeQid .
  op noqid : -> MaybeQid [ctor] .
endfm

fmod QID-TYPELIST-PAIR is
  pr META-LEVEL .
  sort QidTypeListPair QidTypeListPairSet .
  subsort QidTypeListPair < QidTypeListPairSet .
  op ((_,_)) : Qid TypeList                           -> QidTypeListPair    [ctor] .
  op _|_     : QidTypeListPairSet  QidTypeListPairSet -> QidTypeListPairSet [ctor assoc comm id: mt] .
  op mt      :                                        -> QidTypeListPairSet [ctor] .
endfm

fmod BOOL-ERR is
  pr BOOL .
  pr QID-LIST .
  sort NoBool MaybeBool ErrBool BoolErr Bool? .
  subsort Bool NoBool  < MaybeBool < Bool? .
  subsort Bool ErrBool < BoolErr   < Bool? .
  op nobool      :         -> NoBool  [ctor]    .
  op errb        : QidList -> BoolErr [ctor]    .
  op not_        : Bool?   -> Bool?   [prec 53] .
  op true?       : Bool?   -> Bool              .
  op true-undef? : Bool?   -> Bool              .
  eq not nobool           = nobool .
  eq not errb(Q:QidList)  = errb(Q:QidList) .
  ---
  eq true?(true)          = true .
  eq true?(B:Bool?)       = false [owise] .
  eq true-undef?(true)    = true .
  eq true-undef?(nobool)  = true .
  eq true-undef?(B:Bool?) = false [owise] .
endfm

fmod STREAM{X :: TRIV} is
  pr META-LEVEL .
  --- SORTS
  sort Stream{X} .
  --- CTOR
  op _&_ : X$Elt [Stream{X}] -> Stream{X} [strat (1 0) ctor] .
  op _|_ : Stream{X} Stream{X} -> Stream{X} [strat (1 0) ctor] .
  op end : -> Stream{X} [ctor] .
  --- DEF
  op take  : Bound Stream{X} -> Stream{X} .
  op $take : Bound Stream{X} Stream{X} -> Stream{X} .
  op pick! : Nat Stream{X} ~> X$Elt .
  op rest  : Nat Stream{X} -> Stream{X} .
  op last  : Stream{X} -> Stream{X} .
  op last! : Stream{X} ~> X$Elt .
  --- VAR
  var X Y  : X$Elt .
  var S S' : [Stream{X}] .
  var N : Nat .
  var B : Bound .
  --- IMPL
  eq end     | S               = S .
  eq (X & S) | S'              = X & (S | S') .
  eq take(B,S)                 = $take(B,S,end) .
  eq $take(unbounded,X & S,S') = $take(unbounded,S,X & S') .
  eq $take(unbounded,end,S)    = S .
  eq $take(s(N),X & S,S')      = $take(N,S,X & S') .
  eq $take(0,X & S,S')         = S' .
  eq $take(N,end,S')           = S' .
  eq pick!(s(N),X & S)         = pick!(N,S) .
  eq pick!(0,X & S)            = X .
  eq rest(s(N),X & S)          = rest(N,S) .
  eq rest(0,X & S)             = X & S .
  eq rest(N,end)               = end .
  eq last!(X & S)              = last!(S) .
  eq last!(X & end)            = X .
  eq last(X & Y & S)           = last(Y & S) .
  eq last(X & end)             = X & end .
  eq last(end)                 = end .
  --- EXTRA
  op size : Stream{X} -> Nat .
  op $size : Nat Stream{X} -> Nat .
  eq size(S) = $size(0,S) .
  eq $size(N,X & S) = $size(s(N),S) .
  eq $size(N,end) = N .
endfm

fmod TREE-INDEX{X :: TRIV} is
  pr LIST{X} * (sort List{X} to TreeIndex{X}, sort NeList{X} to NeTreeIndex{X}, op nil to noind,
                op __ to _:_, op append to tiappend, op tail to titail, op front to tifront, op reverse to tireverse, op $reverse to $tireverse) .
endfm

fmod N-TREE{X :: TRIV,Y :: TRIV} is
  pr EXT-BOOL . --- and-then definition
  pr TREE-INDEX{X} .

  sort Tree{X,Y} Tree?{X,Y}              .
  sort Branch{X,Y} BranchSet{X,Y}        .
  subsort Branch{X,Y} < BranchSet{X,Y}   .
  subsort Tree{X,Y}   < Tree?{X,Y}       .

  op (_:_:_)    : X$Elt Y$Elt Tree{X,Y}             -> Branch{X,Y}    [ctor] .
  op _|_        : BranchSet{X,Y} BranchSet{X,Y}     -> BranchSet{X,Y} [ctor assoc comm id: nobranch prec 51] .
  op nobranch   :                                   -> BranchSet{X,Y} [ctor] .
  op [_]        : BranchSet{X,Y}                    -> Tree{X,Y}      [ctor] .
  op notree     :                                   -> Tree?{X,Y}     [ctor] .

  --- an empty tree/check for leaves
  op isleaf?    : Branch{X,Y}                       -> Bool .
  op emptree    :                                   -> Tree{X,Y} .
  --- check that no index is duplicated in the tree
  op wellFormed : Tree{X,Y}                         -> Bool .
  op wellFormed : BranchSet{X,Y}                    -> Bool .
  --- extract a subtree/prune at treeindex/prune at depth
  op find       : Tree{X,Y} TreeIndex{X}            -> Tree?{X,Y} .     --- extract subtree at named index
  op prune      : Tree{X,Y} TreeIndex{X}            -> Tree{X,Y}  .     --- cutoff  subtree at named index
  op cut        : Tree{X,Y} Nat                     -> Tree{X,Y}  .     --- extract subtree upto depth
  op cut        : BranchSet{X,Y} BranchSet{X,Y} Nat -> Tree{X,Y}  .
  op graft      : Tree{X,Y} TreeIndex{X} Tree{X,Y}  -> Tree{X,Y}  .     --- insert tree into other tree at treeindex
  op frontier   : Tree{X,Y}                         -> BranchSet{X,Y} . --- extract edge of tree
  op frontier   : BranchSet{X,Y}                    -> BranchSet{X,Y} .
  op depth      : Tree{X,Y}                         -> Nat .            --- find depth of tree
  op depth      : BranchSet{X,Y} Nat                -> Nat .
  ---
  var X : X$Elt . var XS : TreeIndex{X} . var Y Y' : Y$Elt . var T T' : Tree{X,Y} . var BS BS' : BranchSet{X,Y} . var N : Nat .
  ---
  eq wellFormed([X : Y : T | X : Y' : T' | BS]) = false .
  eq wellFormed([BS])                           = wellFormed(BS) [owise] .
  eq wellFormed(X : Y : T | BS)                 = wellFormed(T) and-then wellFormed(BS) .
  eq wellFormed(nobranch)                       = true .
  ---
  eq emptree                           = [nobranch] .
  eq isleaf?(X : Y : T)                = T == emptree .
  ---
  eq find([X : Y : T | BS],X : XS)     = find(T,XS) .
  eq find(T,noind)                     = T .
  eq find(T,XS)                        = notree [owise] .
  ---
  eq prune([X : Y : T | BS],X : XS)    = [X : Y : prune(T,XS) | BS] .
  eq prune(T,noind)                    = emptree .
  eq prune(T,XS)                       = T [owise] .
  ---
  eq cut([BS],s(N))                    = cut(BS,nobranch,N) .
  eq cut(T,0)                          = emptree .
  eq cut(X : Y : T | BS,BS',N)         = cut(BS,BS' | X : Y : cut(T,N),N) .
  eq cut(nobranch,BS',N)               = [BS'] .
  ---
  eq graft([X : Y : T | BS],X : XS,T') = [X : Y : graft(T,XS,T') | BS] .
  eq graft(T,noind,T')                 = T' .
  eq graft(T,XS,T')                    = T [owise] .
  ---
  eq frontier([BS])                    = frontier(BS) .
  eq frontier(X : Y : T | BS)          = if T == emptree then X : Y : T  else frontier(T) fi | frontier(BS) .
  eq frontier(nobranch)                = nobranch .
  ---
  eq depth([nobranch])                 = 0 .
  eq depth([BS])                       = s(depth(BS,0)) [owise] .
  eq depth(X : Y : T | BS,N)           = depth(BS,max(depth(T),N)) .
  eq depth(nobranch,N)                 = N .
endfm

fmod MAP-EXTRA{X :: TRIV, Y :: TRIV} is
  pr MAP{X,Y} .
  pr NAT .
  --- basic operations only defined over maps
  op _[_,_]     : Map{X,Y} X$Elt Y$Elt -> Y$Elt .
  op remove     : X$Elt Map{X,Y} -> Map{X,Y} .
  op haskey     : X$Elt Map{X,Y} -> Bool .
  op size       : Map{X,Y} -> Nat .
  op $size      : Map{X,Y} Nat -> Nat .
  op wellFormed : Map{X,Y} -> Bool .

  var M : Map{X,Y} .
  var E : Entry{X,Y} .
  var K : X$Elt .
  var V V' : Y$Elt .
  var N : Nat .

  --- Default Value Lookup
  --- Returns V if K is not in the map
  eq M [K,V] =
          if not $hasMapping(M,K)
          then V else M [ K ] fi .
  --- Remove an entry from the map
  eq remove(K, (M, K |-> V)) = M .
  eq remove(K, M) = M [owise] .
  --- Check if a key exists in the map
  eq haskey(K, M) = $hasMapping(M,K) .
  --- Get the size of the map
  eq size(M) = $size(M,0) .
  eq $size((M , E), N) = $size(M,s(N)) .
  eq $size(empty,N) = N .
  --- Checks if each key is only mapped once
  eq wellFormed((M, K |-> V, K |-> V')) = false .
  eq wellFormed(M) = true [owise] .
endfm

fth UNIT-LIST is
  sort Elt List .
  subsort Elt < List .
  op _;_ : List List -> List [id: empty] .
  op empty : -> List .
endfth

view UnitList from TRIV to UNIT-LIST is
  sort Elt to List .
endv

fmod LAZY-TUPLE{X :: UNIT-LIST} is
  pr STREAM{UnitList}{X} .
  pr LIST{UnitList}{X} .

  op tuples : List{UnitList}{X}                     -> Stream{UnitList}{X} .
  op ns     : List{UnitList}{X} Stream{UnitList}{X} -> Stream{UnitList}{X} .
  op ones   : X$List                                -> Stream{UnitList}{X} .
  op adds   : X$List X$List Stream{UnitList}{X}     -> Stream{UnitList}{X} .

  var L C C' : X$List .
  var OL     : List{UnitList}{X} .
  var E      : X$Elt .
  var S      : Stream{UnitList}{X} .

  --- INP: List{UnitList{X}}
  --- PRE: None
  --- OUT: Stream{UnitList{X}} where each UnitList in the stream
  ---      represents one possible tuple generated by selecting an
  ---      element from each input UnitList{X} in order
  eq tuples(nil)          = end .
  eq tuples(OL L)         = ns(OL,ones(L)) .
  eq ns(OL L,S)           = ns(OL,adds(L,L,S)) .
  eq ns(nil,S)            = S .
  eq ones(E ; L)          = E & ones(L) .
  eq ones(empty)          = end .
  eq adds(C',E ; C,L & S) = E ; L & adds(C',C,L & S) .
  eq adds(C',empty,L & S) = adds(C',C',S) .
  eq adds(C,C,end)        = end .
endfm

fmod TERM-EXTRA is
  pr TERM-HANDLING .
  op  getName         : QidSet               -> [QidSet] .
  op  getType         : QidSet               -> [QidSet] .
  op  filterByType    : QidSet TypeSet       -> [QidSet] .
  op  varsToTermList  : QidSet               -> [TermList] .
  op  subterms        : Term                 -> TermList .
  op  repeatedNames   : QidSet               -> QidSet .
  op $repeatedNames   : QidSet QidSet QidSet -> QidSet .
  op  termListToTypes : Module TermList      -> TypeList .
  op  termListToKinds : Module TermList      -> TypeList .
  op  len             : TermList             -> Nat .
  op  headName        : Term                 -> Qid .

  var TQ : TermQid . var Q : Qid . var QS QS' QS'' : QidSet . var V : Variable .
  var T : Term . var NTL : NeTermList . var C : Constant . var TS : TypeSet .
  var TL : TermList . var M : Module .

  eq headName(Q[NTL]) = Q .
  eq headName(TQ)     = getName(TQ) .

  --- INP: QidSet
  --- PRE: Each Qid in QidSet is a TermQid
  --- OUT: QidSet composed of the name/sort of each TermQid
  eq getName(TQ ; Q ; QS)   = getName(TQ) ; getName(Q ; QS) .
  eq getName(none)          = none .
  eq getType(TQ ; Q ; QS)   = getType(TQ) ; getType(Q ; QS) .
  eq getType(none)          = none .

  --- INP: QidSet
  --- PRE: Each Qid in QidSet is a TermQid
  --- OUT: Set of names (obtained by getName) which are not unique
  eq  repeatedNames(QS)               = $repeatedNames(QS,none,none) .
  eq $repeatedNames(TQ ; QS,QS',QS'') = if getName(TQ) in QS' then $repeatedNames(QS,QS',QS'' ; getName(TQ))
                                                              else $repeatedNames(QS,QS' ; getName(TQ),QS'') fi .
  eq $repeatedNames(none,QS',QS'')    = QS'' .

  --- INP: QidSet
  --- PRE: Each Qid in QidSet is a TermQid
  --- OUT: QidSet composed of only those TermQids who Type is in TypeSet
  eq filterByType(TQ ; QS,TS) =
    if getType(TQ) in TS then TQ else none fi ; filterByType(QS,TS) .
  eq filterByType(none,TS)    = none .

  --- INP: QidSet
  --- PRE: Each Qid in QidSet is a Variable
  --- OUT: A TermList where each Variable occurs in an undefined order
  eq varsToTermList(V ; QS) = V,varsToTermList(QS) .
  eq varsToTermList(none)   = empty .

  --- INP: Term
  --- PRE: None
  --- OUT: The list of subterms from this term
  eq subterms(Q[NTL]) = NTL .
  eq subterms(C)      = empty .
  eq subterms(V)      = empty .

  --- INP: Module TermList
  --- PRE: Terms are well-formed in Module
  --- OUT: A TypeList corresponding to the TermList
  eq termListToTypes(M,(T,TL)) = leastSort(M,T) termListToTypes(M,TL) .
  eq termListToTypes(M,empty)  = nil .

  --- INP: Module TermList
  --- PRE: Terms are well-formed in Module
  --- OUT: A TypeList (of Kinds) corresponding to the TermList
  eq termListToKinds(M,(T,TL)) = getKind(M,leastSort(M,T)) termListToKinds(M,TL) .
  eq termListToKinds(M,empty)  = nil .

  --- INP: TermList
  --- PRE: None
  --- OUT: Length of the TermList
  eq len((T,TL)) = s(len(TL)) .
  eq len(empty)  = 0 .
endfm

fmod TERMSET-AUX is
  pr TERMSET .
  sort NeTermSet .
  subsort Term < NeTermSet < TermSet .
  op _|_ : TermSet NeTermSet -> NeTermSet [ctor ditto] .
  op termListToSet : TermList    -> TermSet .
  op getECTerms    : EqCondition -> TermSet .
  var T T' : Term . var TL : TermList . var C : EqCondition .
  eq termListToSet((T,TL)) = T | termListToSet(TL) .
  eq termListToSet(empty)  = emptyTermSet .
  eq getECTerms(T = T' /\ C) = T | T' | getECTerms(C) .
  eq getECTerms(nil)         = emptyTermSet .
endfm

fmod TERM-MSET is
  pr META-TERM .
  sort TermMSet NeTermMSet .
  subsort Term < NeTermMSet < TermMSet .
  op _||_ : TermMSet   TermMSet ->   TermMSet [ctor assoc comm id: emptyTermMSet] .
  op _||_ : NeTermMSet TermMSet -> NeTermMSet [ctor ditto] .
  op emptyTermMSet : -> TermMSet [ctor] .
  op termListToMSet : TermList -> TermMSet .
  var T T' : Term . var TL : TermList .
  eq termListToMSet((T,TL)) = T || termListToMSet(TL) .
  eq termListToMSet(empty)  = emptyTermMSet .
endfm

fmod QID-JOIN is
  pr QID-SET * (op empty to none, op _,_ to _;_ [prec 43]) .
  pr QID-LIST .
  pr CONVERSION .
  op joinl  : QidList QidList -> QidList .
  op join   : QidList         -> Qid .
  op join   : QidList String  -> Qid .
  op $join  : QidList String  -> String .
  op tolist : QidSet          -> QidList .
  var Q : Qid . var QL QL' : NeQidList . var QS : QidSet . var S : String .
  eq joinl(Q QL,QL') = Q QL' joinl(QL,QL') .
  eq joinl(Q,QL')    = Q .
  eq joinl(nil,QL')  = nil .

  eq join(nil)       = qid("") .
  eq join(QL)        = qid($join(QL,"")) .
  eq join(nil,S)     = qid("") .
  eq join(QL,S)      = qid($join(QL,S)) .

  eq $join(Q,S)      = string(Q) .
  eq $join(Q QL,S)   = string(Q) + S + $join(QL,S) .
  eq $join(nil,S)    = "" .

  eq tolist(Q ; QS)  = Q tolist(QS) .
  eq tolist(none)    = nil .
endfm

fmod QIDTUPLESET is
  pr QID .
  pr QID-SET * (op empty to none, op _,_ to _;_ [prec 43]) .

  var Q Q' : Qid . var QPS : QidPairSet .

  sort EmptyQidTupleSet QidPairItem QidPairSet QidTripleItem QidTripleSet .
  subsort QidPairItem      < QidPairSet   .
  subsort QidTripleItem    < QidTripleSet .
  subsort EmptyQidTupleSet < QidPairSet QidTripleSet .
  op qp   : Qid Qid                           -> QidPairItem      [ctor] .
  op qt   : Qid Qid Qid                       -> QidTripleItem    [ctor] .
  op _|_  : QidPairSet   QidPairSet           -> QidPairSet       [ctor assoc comm id: none] .
  op _|_  : QidTripleSet QidTripleSet         -> QidTripleSet     [ctor assoc comm id: none] .
  op _|_  : EmptyQidTupleSet EmptyQidTupleSet -> EmptyQidTupleSet [ctor assoc comm id: none] .
  op none :                                   -> EmptyQidTupleSet [ctor] .

  op applyQPS : Qid QidPairSet -> Qid .
  eq applyQPS(Q,qp(Q,Q') | QPS) = Q' .
  eq applyQPS(Q,QPS) = Q [owise] .

  op applyQPS! : Qid QidPairSet ~> Qid .
  eq applyQPS!(Q,qp(Q,Q') | QPS) = Q' .
endfm

fmod STRING-EXTRA is
  pr STRING .
  pr NAT .

  op isSpace?  : Char -> Bool .
  op stripL    : String -> String .
  op stripL    : String Nat -> String .
  op stripL    : String String Nat -> String .

  op insert    : String Nat Nat String -> String .

  op replace   : String String String ~> String .
  op replace   : String String String Nat ~> String .
  op $replace1 : String String Nat String Nat FindResult Nat Nat -> String .
  op $replace? : String String Nat String Nat Nat Nat Nat -> String .

  var Z : Char .
  var S O R : String .
  var N L1 L2 P1 P2 I C : Nat .
  var P : NzNat .

  --- INP: String
  --- PRE: None
  --- OUT: A string with no whitespace on the front
  eq stripL(S)      = stripL(S,length(S)) .
  eq stripL("",0)   = "" .
  eq stripL(S,P)    = stripL(substr(S,0,1),substr(S,1,sd(P,1)),sd(P,1)) .
  eq stripL(Z,S,P)  = if isSpace?(Z) then stripL(substr(S,0,1),substr(S,1,sd(P,1)),sd(P,1))
                                    else Z + S fi .
  eq stripL(Z,"",0) = if isSpace?(Z) then "" else Z fi .

  --- INP: Char
  --- PRE: None
  --- OUT: true iff this character represents a space
  eq isSpace?(" ")  = true .
  eq isSpace?("\t") = true .
  eq isSpace?("\n") = true .
  eq isSpace?("\r") = true .
  eq isSpace?(Z)    = false [owise] .

  --- INP: String1 Nat1 Nat2 String2
  --- PRE: None
  --- OUT: Replaces substr(String1,Nat1,sd(Nat2,Nat1)) with String2
  eq insert(S,P1,P2,R) = substr(S,0,P1) + R + substr(S,P2,length(S)) .

  --- INP: String0 String1 String2 [Nat]
  --- PRE: None
  --- OUT: Replaces first [Nat] occurences of String1 with String2 in String0
  eq replace(S,O,R) = replace(S,O,R,length(S)) .
  ceq replace(S,O,R,N) =
    if N == 0 then
      S
    else
      $replace1(S,O,length(O),R,length(R),find(S,O,0),0,s(N))
    fi
  if O =/= "" .
  eq $replace1(S,O,L1,R,L2,notFound,C,N) = S .
  eq $replace1(S,O,L1,R,L2,I,C,N) = $replace?(insert(S,I,I + L1,R),O,L1,R,L2,I,s(C),N) .
  eq $replace?(S,O,L1,R,L2,I,C,N) =
    if C < N then
      $replace1(S,O,L1,R,L2,find(S,O,I + L2),C,N)
    else
      S
    fi .
endfm

fmod MOD-EXTRA is
  pr UNIT .
  op protecting? : Module Module -> Bool .
  op protecting? : ModuleExpression ImportList -> Bool .
  var ME ME' : ModuleExpression . var IL : ImportList . var M M' : Module .
  eq protecting?(M,M') = protecting?(getName(M'),getImports(M)) .
  eq protecting?(ME,protecting ME' . IL) = ME == ME' or-else protecting?(ME,IL) .
  eq protecting?(ME,including  ME' . IL) = protecting?(ME,IL) .
  eq protecting?(ME,extending  ME' . IL) = protecting?(ME,IL) .
  eq protecting?(ME,nil) = false .
endfm

fmod TYPE-EXTRA is
  pr META-LEVEL .

  --- LIST OPERATION
  op len               : TypeList -> Nat .
  op len               : TypeList Nat -> Nat .

  --- BASIC TYPE OPERATIONS
  op direct-subsorts   : Module Type -> SortSet .
  op direct-subsorts   : SubsortDeclSet Type -> SortSet .

  --- BASIC TYPE SET OPERATIONS
  op getMaximalSorts   : Module -> SortSet .
  op getMaximalSorts   : Module KindSet -> SortSet .

  --- BASIC TYPE TUPLE OPERATIONS
  op $typeLeq          : Module TypeList TypeList -> Bool .
  op $typeLeqS         : Module TypeList TypeListSet -> Bool .
  op typeLeqS          : Module TypeListSet TypeListSet -> Bool .
  op $typeRel          : Module TypeList TypeList -> Bool .
  op $typeRelS         : Module TypeList TypeListSet -> Bool .
  op typeRelS          : Module TypeListSet TypeListSet -> Bool .
  op greaterSorts      : Module Sort -> SortSet .
  op $greaterSorts     : Module Sort SortSet -> SortSet .

  --- BASIC TYPE TUPLE SET OPERATIONS
  op _in_              : TypeList TypeListSet -> Bool .
  op _-_               : TypeListSet TypeListSet -> TypeListSet .
  op $tydiff           : TypeListSet TypeListSet TypeListSet -> TypeListSet .
  op intersect         : TypeListSet TypeListSet -> TypeListSet .

  --- TYPE TUPLE AUXILLIARY OPERATIONS
  op merge             : TypeListSet TypeListSet -> TypeListSet .
  op $merge1           : TypeListSet TypeListSet TypeListSet -> TypeListSet .
  op $merge2           : TypeList TypeListSet TypeListSet -> TypeListSet .

  --- CONVERSIONS
  op typeListToSet     : TypeList -> TypeSet .
  op toKindList        : Module TypeList -> TypeList .

  --- DECL TYPE OPERATIONS
  op possibleTypings   : Module Qid -> TypeSet .

  var SDS : SubsortDeclSet .
  var TYLS TYLS' TYLS'' : TypeListSet .
  var TYS : TypeSet .
  var TY TY' : Type .
  var S S' : Sort .
  var K K' : Kind .
  var KS : KindSet .
  var TYL TYL' TYL'' : TypeList .
  var SS SS' : SortSet .
  var M : Module .
  var Q Q' : Qid .
  var ODS : OpDeclSet .
  var AS : AttrSet .
  var N : Nat .

  --- INP: TypeList
  --- PRE: None
  --- OUT: Length of the TypeList
  eq len(TYL)      = len(TYL,0) .
  eq len(TY TYL,N) = len(TYL,s(N)) .
  eq len(nil,N)    = N .

  --- INP: Module Type
  --- PRE: Type is well-defined in Module
  --- OUT: Set of direct subsorts of Type
  eq direct-subsorts(M,S) = direct-subsorts(getSubsorts(M),S) .
  eq direct-subsorts(M,K) = maximalSorts(M,K) .
  eq direct-subsorts(SDS subsort S' < S .,S) = S' ; direct-subsorts(SDS,S) .
  eq direct-subsorts(SDS,TY) = none [owise] .

  --- INP: Module [KindSet]
  --- PRE: Kinds are well-defined in Module
  --- OUT: Set of maximal sorts of each kind
  eq getMaximalSorts(M)        = getMaximalSorts(M,getKinds(M)) .
  eq getMaximalSorts(M,K ; KS) = maximalSorts(M,K) ; getMaximalSorts(M,KS) .
  eq getMaximalSorts(M,none)   = none .

  --- INP: Module TypeListSet1 TypeListSet2
  --- PRE: Types in TypeLists are defined in Module
  --- OUT: true if every type in TypeListSet1 is a subtype of TypeListSet2
  eq $typeLeq(M,K TYL,S TYL')  = false .
  eq $typeLeq(M,S TYL,K TYL')  = sortLeq(M,S,K)  and-then $typeLeq(M,TYL,TYL') .
  eq $typeLeq(M,K TYL,K' TYL') = sortLeq(M,K,K') and-then $typeLeq(M,TYL,TYL') .
  eq $typeLeq(M,S TYL,S' TYL') = sortLeq(M,S,S') and-then $typeLeq(M,TYL,TYL') .
  eq $typeLeq(M,nil,nil)       = true .
  eq $typeLeq(M,TYL,TYL')      = false [owise] .
  eq $typeLeqS(M,TYL,TYL' ; TYLS) =
    $typeLeq(M,TYL,TYL') and-then $typeLeqS(M,TYL,TYLS) .
  eq $typeLeqS(M,TYL,none) = true .
  eq typeLeqS(M,TYL ; TYLS,TYLS') =
    $typeLeqS(M,TYL,TYLS') and-then typeLeqS(M,TYLS,TYLS') .
  eq typeLeqS(M,none,TYLS') = true .

  --- INP:  Module TypeListSet1 TypeListSet2
  --- PRE:  Types in TypeLists are defined in Module
  --- OUT:  true if corresponding types in each typelist have the same kind
  --- NOTE: the mnemonic typeRel stands for type related
  eq $typeRel(M,TY TYL,TY' TYL') = sameKind(M,TY,TY') and $typeRel(M,TYL,TYL') .
  eq $typeRel(M,nil,nil)         = true .
  eq $typeRel(M,TYL,TYL')        = false [owise] .
  eq $typeRelS(M,TYL,TYL' ; TYLS) =
    $typeRel(M,TYL,TYL') and-then $typeRelS(M,TYL,TYLS) .
  eq $typeRelS(M,TYL,none) = true .
  eq typeRelS(M,TYL ; TYLS,TYLS') =
    $typeRelS(M,TYL,TYLS') and-then typeRelS(M,TYLS,TYLS') .
  eq typeRelS(M,none,TYLS') = true .

  --- INP: Module Sort
  --- PRE: Type is defined in Module
  --- OUT: SortSet of all types greater than Sort
  eq greaterSorts(M,S) = $greaterSorts(M,S,lesserSorts(M,getKind(M,S))) .
  eq $greaterSorts(M,S,S' ; SS) =
    if sortLeq(M,S,S') then
      S' ; $greaterSorts(M,S,SS)
    else
      $greaterSorts(M,S,SS)
    fi .
  eq $greaterSorts(M,S,none) = none .

  --- INP: TypeList TypeListSet
  --- PRE: None
  --- OUT: true iff TypeList is in TypeListSet
  eq TYL in (TYL ; TYLS) = true .
  eq TYL in TYLS = false [owise] .

  --- INP: TypeListSet1 TypeListSet2
  --- PRE: None
  --- OUT: TypeListSet containing all TypeLists in TypeListSet1 and not in
  ---      TypeListSet2
  eq TYLS - TYLS' = $tydiff(TYLS,TYLS',none) .
  eq $tydiff(TYL ; TYLS,TYLS',TYLS'') =
    if TYL in TYLS' then
      $tydiff(TYLS,TYLS',TYLS'')
    else
      $tydiff(TYLS,TYLS',TYL ; TYLS'')
    fi .
  eq $tydiff(none,TYLS',TYLS'') = TYLS'' .

  --- INP: TypeListSet1 TypeListSet2
  --- PRE: None
  --- OUT: TypeListSet containing all items in both sets
  eq intersect(TYL ; TYLS,TYLS') =
    if TYL in TYLS' then
      TYL ; intersect(TYLS,TYLS')
    else
      intersect(TYLS,TYLS')
    fi .
  eq intersect(none,TYLS') = none .

  --- INP: TypeListSet TypeListSet
  --- PRE: None
  --- OUT: A TypeListSet formed by merging each pair of TypeLists
  ---      in the two TypeListSets
  eq merge(TYLS,TYLS') = $merge1(TYLS,TYLS',none) .
  eq $merge1(TYL ; TYLS, TYLS', TYLS'') =
    $merge1(TYLS, TYLS', $merge2(TYL,TYLS',none) ; TYLS'') .
  eq $merge1(none,TYLS',TYLS'') = TYLS'' .
  eq $merge2(TYL, TYL' ; TYLS, TYLS') =
    $merge2(TYL, TYLS, TYL TYL' ; TYLS') .
  eq $merge2(TYL, none, TYLS') = TYLS' .

  --- INP: TypeList
  --- PRE: None
  --- OUT: Turns a TypeList into the corresponding TypeSet
  eq typeListToSet(TY TYL) = TY ; typeListToSet(TYL) .
  eq typeListToSet(nil)    = none .

  --- INP: Module TypeList
  --- PRE: Types are well-defined in Module
  --- OUT: A list of Kinds
  eq toKindList(M,TY TYL) = getKind(M,TY) toKindList(M,TYL) .
  eq toKindList(M,nil)    = nil .

  --- INP: Module Qid
  --- PRE: None
  --- OUT: Possible result types of operators with name Qid
  op possibleTypings : OpDeclSet Qid -> TypeSet .
  eq possibleTypings(M,Q) = possibleTypings(getOps(M),Q) .
  eq possibleTypings(op Q' : TYL -> TY [AS]. ODS,Q) =
    if Q == Q' then
      TY ; possibleTypings(ODS,Q)
    else
      possibleTypings(ODS,Q)
    fi .
  eq possibleTypings(none,Q) = none .
endfm

fmod TYPESETLIST is
  pr META-LEVEL .

  sort TypeSetList .
  subsort TypeSet < TypeSetList .
  op nilTSL : -> TypeSetList [ctor] .
  op _l_ : TypeSetList TypeSetList -> TypeSetList
     [ctor assoc id: nilTSL] .
endfm

fmod OPDECLSET-EXTRA is
  pr OPDECL-EXTRA .
  pr META-MODULE .

  op _inODS_     : OpDecl OpDeclSet -> Bool .
  op _-_         : OpDeclSet OpDeclSet -> OpDeclSet .
  op subset?     : OpDeclSet OpDeclSet -> Bool .
  op $opdiff     : OpDeclSet OpDeclSet OpDeclSet -> OpDeclSet .
  op argTypeSet  : OpDeclSet -> TypeListSet .
  op $argTypeSet : OpDeclSet TypeListSet -> TypeListSet .
  op resTypeSet  : OpDeclSet -> TypeSet .
  op $resTypeSet : OpDeclSet TypeSet -> TypeListSet .
  op constants   : OpDeclSet -> OpDeclSet .
  op $constants  : OpDeclSet OpDeclSet -> OpDeclSet .
  op ctors       : OpDeclSet -> OpDeclSet .
  op stripAttrs  : OpDeclSet -> OpDeclSet .
  ---
  op qid         : OpDeclSet -> QidSet .
  op argTypes    : OpDeclSet -> TypeListSet .
  op resultType  : OpDeclSet -> TypeSet .
  --- op attrSet : OpDeclSet -> AttrSetSet . --- right now no attrsetset sort to use...

  var TS : TypeSet .
  var TLS : TypeListSet .
  var ODS ODS' ODS'' : OpDeclSet .
  var OD OD' : OpDecl .
  var Q : Qid .
  var AS : AttrSet .
  var TYL : TypeList .
  var TY : Type .
  var QS : QidSet .

  --- INP: OpDecl OpDeclSet
  --- PRE: None
  --- OUT: true iff OpDecl is in OpDeclSet
  eq OD inODS OD ODS = true .
  eq OD inODS ODS = false [owise] .

  --- INP: OpDeclSet1 OpDeclSet2
  --- PRE: None
  --- OUT: Removes all OpDecls in set 2
  ---      from set 1
  eq ODS - ODS' = $opdiff(ODS,ODS',none) .
  eq $opdiff(OD ODS,ODS',ODS'') =
    $opdiff(ODS,ODS',if OD inODS ODS' then none else OD fi ODS'') .
  eq $opdiff(none,ODS',ODS'') = ODS'' .

  --- INP: OpDeclSet1 OpDeclSet2
  --- PRE: None
  --- OUT: true iff OpDeclSet1 is a subset of OpDeclSet2
  eq subset?(OD ODS,ODS') = OD inODS ODS' and-then subset?(ODS,ODS') .
  eq subset?(none,ODS') = true .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: A set of TypeLists represents the arguments from each OpDecl
  eq argTypeSet(ODS) = $argTypeSet(ODS,none) .
  eq $argTypeSet(OD ODS,TLS) = $argTypeSet(ODS,argTypes(OD) ; TLS) .
  eq $argTypeSet(none,TLS) = TLS .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: A TypeSet representing the results from each OpDecl
  eq resTypeSet(ODS) = $resTypeSet(ODS,none) .
  eq $resTypeSet(OD ODS,TS) = $resTypeSet(ODS,resultType(OD) ; TS) .
  eq $resTypeSet(none,TS) = TS .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Extracts all constants
  eq constants(ODS) = $constants(ODS,none) .
  eq $constants(OD ODS,ODS') =
    $constants(ODS,if argTypes(OD) == nil then OD else none fi ODS') .
  eq $constants(none,ODS') = ODS' .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Extracts all ctors
  op $ctors      : OpDeclSet OpDeclSet -> OpDeclSet .
  eq ctors(ODS) = $ctors(ODS,none) .
  eq $ctors(op Q : TYL -> TY [ctor AS]. ODS,ODS') =
     $ctors(ODS,op Q : TYL -> TY [ctor AS]. ODS') .
  eq $ctors(ODS,ODS') = ODS' [owise] .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Replaces each op's AttrSet with none
  eq stripAttrs(op Q : TYL -> TY [AS]. ODS) =
   op Q : TYL -> TY [none]. stripAttrs(ODS) .
  eq stripAttrs(none) = none .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: Qid/TypeList/TypeSets (Set functor liftings of OpDecl type)
  eq qid(OD OD' ODS)        = qid(OD) ; qid(OD' ODS) .
  eq qid(none)              = none .
  eq argTypes(OD OD' ODS)   = argTypes(OD) ; argTypes(OD' ODS) .
  eq argTypes(none)         = none .
  eq resultType(OD OD' ODS) = resultType(OD) ; resultType(OD' ODS) .
  eq resultType(none)       = none .
endfm

fmod OPDECL-ORDER is
  pr META-LEVEL .
  pr TYPE-EXTRA .
  pr OPDECL-EXTRA .

  op opLeq : Module OpDecl OpDecl -> Bool .
  op getMaximal : Module OpDeclSet -> OpDeclSet .
  op $getMaximal : Module OpDeclSet OpDeclSet OpDeclSet -> OpDeclSet .
  op $getMaximal1 : Module OpDecl OpDeclSet -> Bool .
  op opsBelow : Module OpDecl -> OpDeclSet .
  op opsBelow : Module OpDecl OpDeclSet -> OpDeclSet .
  op $opsBelow : Module OpDecl OpDeclSet OpDeclSet -> OpDeclSet .
  op relatedOps : Module Qid TypeList OpDeclSet -> OpDeclSet .
  op relatedOps : Module OpDecl OpDeclSet -> OpDeclSet .

  var M : Module .
  var OD OD' : OpDecl .
  var ODS ODS' ODS'' : OpDeclSet .
  var Q : Qid .
  var TYL : TypeList .

  --- INP: Module OpDecl1 OpDecl2
  --- PRE: OpDecls are well-defined with respect to Module
  --- OUT: true iff names agree and argTypes of OpDecl1 are less than that
  ---      of OpDecl2
  eq opLeq(M,OD,OD') =
    qid(OD) == qid(OD') and-then typeLeqS(M,argTypes(OD),argTypes(OD')) .

  --- INP: Module OpDeclSet
  --- PRE: OpDeclSet is well-defined with respect to Module
  --- OUT: The maximal OpDecls in the OpDeclSet
  eq getMaximal(M,ODS) = $getMaximal(M,ODS,none,none) .
  eq $getMaximal(M,OD ODS,ODS',ODS'') =
    if $getMaximal1(M,OD,ODS ODS') then
      $getMaximal(M,ODS,OD ODS',OD ODS'')
    else
      $getMaximal(M,ODS,ODS',ODS'')
    fi .
  eq $getMaximal(M,none,ODS',ODS'') = ODS'' .
  eq $getMaximal1(M,OD,OD' ODS) =
    not opLeq(M,OD,OD') and-then $getMaximal1(M,OD,ODS) .
  eq $getMaximal1(M,OD,none) = true .

  --- INP: Module OpDecl [OpDeclSet]
  --- PRE: OpDecls are well-defined with respect to Module
  --- OUT: All OpDecls in OpDeclSet that are less than OpDecl
  eq opsBelow(M,OD) = opsBelow(M,OD,getOps(M)) .
  eq opsBelow(M,OD,ODS) = $opsBelow(M,OD,ODS,none) .
  eq $opsBelow(M,OD,OD' ODS',ODS) =
    if opLeq(M,OD',OD) and OD' =/= OD then
      $opsBelow(M,OD,ODS',OD' ODS)
    else
      $opsBelow(M,OD,ODS',ODS)
    fi .
  eq $opsBelow(M,OD,none,ODS) = ODS .

  --- INP: Module OpDecl/(Qid TypeList) OpDeclSet
  --- PRE: OpDecls are well-defined with respect to Module
  --- OUT: Set of OpDecls in OpDeclSet that are related to OpDecl; that is
  ---      their arguments are in the same kind
  eq relatedOps(M,Q,TYL,ODS) =
    relatedOps(M,op Q : TYL -> 'Sort [none].,ODS) .
  eq relatedOps(M,OD,OD' ODS) =
    if qid(OD) == qid(OD') and typeRelS(M,argTypes(OD),argTypes(OD')) then
      OD' relatedOps(M,OD,ODS)
    else
      relatedOps(M,OD,ODS)
    fi .
  eq relatedOps(M,OD,none) = none .
endfm

fmod OPDECL-TYPING is
  pr META-LEVEL .
  pr TERM-HANDLING .
  pr TYPE-EXTRA .
  pr OPDECL-EXTRA .
  pr TERM-EXTRA .

  op termListSorts : Module TermList -> TypeList .
  op findOps : Module OpDeclSet Qid TypeList Type -> OpDeclSet .
  op findOps : Module OpDeclSet Term -> OpDeclSet .
  op overloaded? : OpDeclSet -> Bool .

  var M : Module .
  var OD : OpDecl .
  var ODS : OpDeclSet .
  var Q : Qid .
  var TY TY' : Type .
  var AS AS' : AttrSet .
  var TYL TYL' : TypeList .
  var T : Term .
  var NTL : NeTermList .
  var C : Constant .
  var V : Variable .
  var TL : TermList .

  --- INP: Module TermList
  --- PRE: Term well-defined in Module
  --- OUT: A TypeList with n elements corresponding to n terms' types in termlist
  eq termListSorts(M,(T, TL))  = leastSort(M,T) termListSorts(M,TL) .
  eq termListSorts(M,empty) = nil .

  --- INP: Module OpDeclSet Qid TypeList Type
  --- PRE: TypeList and Type are defined in Module
  --- OUT: Given a term with structure Q(X1...XN) whose
  ---      least sort is Type where the sorts of X1...XN
  ---      correspond to the Types in TypeList, find all
  ---      possible operators in the OpDeclSet that
  ---      could be instantiated to get this term
  eq findOps(M,OD ODS,Q,TYL,TY) =
    if typeLeqS(M,TYL,argTypes(OD)) and qid(OD) == Q and
        typeLeqS(M,resultType(OD),TY) then
      OD
    else
      none
    fi findOps(M,ODS,Q,TYL,TY) .
  eq findOps(M,none,Q,TYL,TY) = none .

  --- INP: SModule Term
  --- PRE: Term and OpDeclSet are well-defined in Module
  --- OUT: Set of OpDecls that could top this term
  eq findOps(M,ODS,T) =
    findOps(M,ODS,root(T),termListSorts(M,subterms(T)),leastSort(M,T)) .

  --- INP: OpDeclSet
  --- PRE: None
  --- OUT: True iff no operators share the same name in OpDeclSet
  eq overloaded?(op Q : TYL -> TY [AS]. op Q : TYL' -> TY' [AS']. ODS) = true .
  eq overloaded?(ODS)                                                  = false [owise] .
endfm

--- this module has functionality to generate unique prefixes with
--- respect to the sorts/operators in a module; this is useful when
--- an algorithm needs to generate fresh sorts/operators; if the
--- generated sort/operator will be needed often, it can be memoized
fmod UNIQUE-PREFIX is
  pr META-LEVEL .
  pr OPDECLSET-EXTRA .
  pr SET{String} .

  op sortPrefix     : Module             -> String [memo] .
  op sortPrefix     : SortSet            -> String .
  op opPrefix       : Module             -> String [memo] .
  op opPrefix       : OpDeclSet          -> String .
  op uniquePrefix   : QidSet             -> String .
  op uniquePrefix   : String Set{String} -> String .
  op qidSetToStrSet : QidSet             -> Set{String} .
  op freshSort      : String Sort        -> Sort .
  op freshOpId      : String Qid         -> Qid .

  var P S : String . var SS : Set{String} . var D : Qid . var Q : QidSet .
  var QI : Qid . var ST : Sort .

  eq sortPrefix(M:Module)   = uniquePrefix(getSorts(M:Module)) .
  eq sortPrefix(S:SortSet)  = uniquePrefix(S:SortSet) .
  eq opPrefix(M:Module)     = uniquePrefix(qid(getOps(M:Module))) .
  eq opPrefix(O:OpDeclSet)  = uniquePrefix(qid(O:OpDeclSet)) .
  eq uniquePrefix(Q)        = uniquePrefix("@",qidSetToStrSet(Q)) .
  eq uniquePrefix(P,(S,SS)) = if P == substr(S,0,length(P)) then uniquePrefix(P + "@",(S,SS))
                                                         else uniquePrefix(P,SS) fi .

  eq uniquePrefix(P,empty)  = P .
  eq qidSetToStrSet(D ; Q)  = string(D) , qidSetToStrSet(Q) .
  eq qidSetToStrSet(none)   = empty .

  eq freshSort(S,ST)        = qid(S + string(ST)) .
  eq freshOpId(S,QI)        = qid(S + string(QI)) .
endfm

--- this module provides functionality to add a set of variables into a module
--- as FRESH constants (by using the functionality of opPrefix above); the function
--- returns a new module as well as an assignment mapping each variable into its
--- fresh constant --- this assignment can later be used to decode the new term
--- back into its original form
fmod VARIABLES-TO-CONSTANTS is
  pr TERM-EXTRA .              --- for getName()/repeatedNames()
  pr UNIT .                    --- for addOps()
  pr QID-JOIN .                --- for join()
  pr UNIQUE-PREFIX .           --- for opPrefix()
  pr SUBSTITUTION-REFINEMENT . --- for sort ConstSubstitution
  pr SUBSTITUTIONSET .         --- for sort SubstitutionSet()

  sort ModuleSubstPair .
  op ((_,_)) : Module Substitution -> ModuleSubstPair [ctor] .
  op mod : ModuleSubstPair -> Module .
  op sub : ModuleSubstPair -> Substitution .

  sort ConstGenStrategy .
  ops simple prefix full : -> ConstGenStrategy [ctor] .

  op  varsToConsts  : Module ConstGenStrategy QidSet                            -> [Module] .
  op  varsToConsts# : Module ConstGenStrategy QidSet                            -> [ModuleSubstPair] .
  op  varsToConsts# : Module ConstGenStrategy QidSet Qid OpDeclSet Substitution -> [ModuleSubstPair] .

  op  constsToVars  : ConstSubstitution Term                                    -> Term .
  op  constsToVars  : ConstSubstitution Qid TermList TermList                   -> TermList .
  op  constsToVars  : ConstSubstitution SubstitutionSet                         -> SubstitutionSet .

  var M : Module . var V : Variable . var C : Constant . var Q : Qid .
  var QS : QidSet . var TL TL' : TermList . var T : Term . var SS : SubstitutionSet .
  var S S' : Substitution . var P : Qid . var O : OpDeclSet . var CG : ConstGenStrategy .
  var TQ : TermQid . var CS : ConstSubstitution .

  --- INP: Module QidSet (Variables)
  --- PRE: QidSet should be a set of variables
  --- OUT: A new module where variables have been added as constants
  eq mod((M,CS)) = M .
  eq sub((M,CS)) = CS .
  eq varsToConsts(M,CG,QS)                 = mod(varsToConsts#(M,CG,QS)) .
  eq varsToConsts#(M,CG,QS)                = varsToConsts#(M,CG,QS,qid(opPrefix(M)),none,none) .
  eq varsToConsts#(M,simple,V ; QS,P,O,CS) = varsToConsts#(M,simple,QS,P,O op getName(V)                       : nil -> getType(V) [none].,CS ; V <- join(getName(V) '. getType(V))) .
  eq varsToConsts#(M,prefix,V ; QS,P,O,CS) = varsToConsts#(M,prefix,QS,P,O op join(P getName(V))               : nil -> getType(V) [none].,CS ; V <- join(P getName(V) '. getType(V))) .
  eq varsToConsts#(M,full,  V ; QS,P,O,CS) = varsToConsts#(M,full,  QS,P,O op join(P getName(V) '| getType(V)) : nil -> getType(V) [none].,CS ; V <- join(P getName(V) '| getType(V) '. getType(V))) .
  eq varsToConsts#(M,CG,none,P,O,CS)       = (addOps(O,M),CS) .

  --- INP: Substitution (Variables to fresh Constants) Term/SubstitutionSet
  --- PRE: None
  --- OUT: Identical to Term/SubstitutionSet except in Term/Codomain of SubstitutionSet
  ---      each occurrence of a constant in the codomain of Substitution is
  ---      replaced by the variable which is assigned to it
  eq constsToVars(CS,Q[TL])         = constsToVars(CS,Q,TL,empty) .
  eq constsToVars(CS,V)             = V .
  eq constsToVars(CS ; V <- C,C)    = V .
  eq constsToVars(CS,C)             = C [owise] .
  eq constsToVars(CS,Q,(T,TL),TL')  = constsToVars(CS,Q,TL,(TL',constsToVars(CS,T))) .
  eq constsToVars(CS,Q,empty,TL')   = Q[TL'] .
  ---
  eq constsToVars(CS,S | S' | SS)             = constsToVars(CS,S) | constsToVars(CS,S' | SS) .
  eq constsToVars(CS,(empty).SubstitutionSet) = (empty).SubstitutionSet .
  eq constsToVars(CS,V <- T ; S)              = V <- constsToVars(CS,T) ; constsToVars(CS,S) .
  eq constsToVars(CS,(none).Substitution)     = (none).Substitution .
endfm

fmod MODULE-DATABASE-IMP{X :: TRIV} is
  pr MAP-EXTRA{X,Module} * (sort Map{X,Module} to ModuleDatabase{X}, sort MapEntry{X,Module} to ModuleEntry{X}) .
endfm

fmod GENERIC-PRINTER is
  pr DECL-META-PRETTY-PRINT .
  pr TERMSET                .
  pr CONVERSION             .

  ops &mt &sp  :                     -> Qid     . --- constants for nothing/space
  op  pad      : Qid Nat             -> QidList . --- add padding upto length
  op  addsp    : Nat                 -> QidList .
  op  print    : Module TermSet      -> QidList . --- printing fuctions below
  op  printSub : Module Substitution -> QidList .
  op  print    : NatList QidList     -> QidList .
  op  printNL  : NatList QidList     -> QidList .

  var M  : Module  . var SB : Substitution . var T T' : Term . var Q : Qid .
  var TS : TermSet . var A A' : Assignment . var NL : NatList .
  var QL : QidList . var V : Variable      . var N : Nat .

  eq addsp(s(N))               = &sp addsp(N) .
  eq addsp(0)                  = nil .
  eq pad(Q,N)                  = Q if length(string(Q)) >= N then nil else addsp(sd(length(string(Q)),N)) fi .
  eq &sp                       = qid(" ") .
  eq &mt                       = qid("")  .
  --- print termsets
  eq print(M,T | T' | TS)      = eMetaPrettyPrint(M,T) '`, print(M,T' | TS) .
  eq print(M,T)                = eMetaPrettyPrint(M,T) .
  eq print(M,emptyTermSet)     = &mt .
  --- print substitutions
  eq printSub(M,V <- T)        = eMetaPrettyPrint(M,V) '<- eMetaPrettyPrint(M,T) .
  eq printSub(M,A ; A' ; SB)   = printSub(M,A) '; printSub(M,A' ; SB) .
  eq printSub(M,none)          = 'empty 'substitution .
  --- print natlist
  eq print(NL,QL)              = printNL(NL,QL) .
  eq printNL(N NL,QL)          = printNL(NL,QL qid(string(N,10))) .
  eq printNL((nil).NatList,QL) = QL .
endfm

fmod TOP-MODULE is
  pr STRING-EXTRA .
  pr QIDTUPLESET  .
  pr META-LEVEL   .
  pr UNIT         .
  pr CONVERSION   .

  var S S' : Sort   . var SS : SortSet .
  var K K' : Kind   . var KS : KindSet .
  var Y    : Type   . var YS : TypeList .
  var SR   : String . var M  : Module  .
  var N    : Nat    .

  --- map kinds to sorts
  op k2s-map   : Module          -> QidPairSet     [memo] .
  op k2s-map   : KindSet         -> QidPairSet     .
  op k2s       : KindSet         -> SortSet        .
  op k2s       : Kind            -> Sort           .
  op k2s       : String          -> Sort           .
  op k2s-map   : Module TypeList -> Type           .
  --- abbreviated kind to identifier map
  op k2s-map#  : Module          -> QidPairSet     [memo] .
  op k2s-map#  : KindSet Nat     -> QidPairSet     .
  op k2s-map#  : Module TypeList -> TypeList       .
  --- top the signature
  op top-subs  : Module KindSet -> SubsortDeclSet .
  op top-subs  : Sort SortSet   -> SubsortDeclSet .
  op top       : Module         -> Module         .

  eq k2s(none)           = none .
  eq k2s(K ; K' ; KS)    = k2s(K) ; k2s(K' ; KS) .
  eq k2s(K)              = k2s(string(K)) .
  eq k2s(SR)             = qid("|" + replace(substr(substr(SR,0,sd(length(SR),2)),2,sd(length(SR),4)),"`,","|") + "|") .

  eq k2s-map(M)          = k2s-map(getKinds(M)) .
  eq k2s-map(K ; KS)     = qp(K,k2s(K)) | k2s-map(KS) .
  eq k2s-map(none)       = none .

  eq k2s-map(M,Y YS)     = applyQPS!(getKind(M,Y),k2s-map(M)) k2s-map(M,YS) .
  eq k2s-map(M,nil)      = nil .

  eq k2s-map#(M)         = k2s-map#(getKinds(M),0) .
  eq k2s-map#(K ; KS,N)  = qp(K,qid("Kind#" + string(N,10))) | k2s-map#(KS,s(N)) .
  eq k2s-map#(none,N)    = none .

  eq k2s-map#(M,Y YS)    = applyQPS!(getKind(M,Y),k2s-map#(M)) k2s-map#(M,YS) .
  eq k2s-map#(M,nil)     = nil .

  eq top(M)              = addSorts(k2s(getKinds(M)),addSubsorts(top-subs(M,getKinds(M)),M)) .
  eq top-subs(M,K ; KS)  = top-subs(k2s(K),lesserSorts(M,K)) top-subs(M,KS) .
  eq top-subs(M,none)    = none .
  eq top-subs(S,S' ; SS) = subsort S' < S . top-subs(S,SS) .
  eq top-subs(S,none)    = none .
endfm

fmod TERMPAIRSET is
  pr META-LEVEL .
  pr TERMSET .
  var T T' T1 T2 : Term . var TPS : TermPairSet . var M : Module .

  sort TermPair TermPairSet .
  subsort TermPair < TermPairSet .
  op ((_:_))      : Term Term -> TermPair [ctor] .
  op _|_          : TermPairSet TermPairSet -> TermPairSet [ctor assoc comm id: .TermPairSet] .
  op .TermPairSet : -> TermPairSet [ctor] .

  op toTermSet : TermPairSet -> TermSet .
  eq toTermSet((T1 : T2) | TPS) = T1 | T2 | toTermSet(TPS) .
  eq toTermSet(.TermPairSet) = emptyTermSet .

  op _<|(_)_ : TermPair Module TermPairSet -> Bool .
  eq (T : T')<|(M) (T1 : T2) | TPS =
    (metaMatch(M,T1,T ,nil,0) :: Substitution and-then
     metaMatch(M,T2,T',nil,0) :: Substitution) or-else (T : T')<|(M) TPS .
  eq (T : T')<|(M) .TermPairSet = false .
endfm

--- creates an unsortified version of a module
--- NOTE: by default renames constants so that constants
---       in the unsorted module cannot be adhoc-overloaded
---       because adhoc-overloading is dangerous when sort
---       information is removed and we don't want that
fmod UNSORTIFY is
  pr META-LEVEL .
  pr QID-JOIN   .
  pr ATTR-EXTRA .
  pr QIDTUPLESET .
  pr TOP-MODULE .
  pr UNIT .
  pr TERMPAIRSET .

  var M : Module .
  var TY : Type .
  var TYL : TypeList .
  var ODS : OpDeclSet .
  var EQS : EquationSet .
  var RLS : RuleSet .
  var AS : AttrSet .
  var T T' : Term .
  var TL : TermList .
  var TPS : TermPairSet .
  var NTL : NeTermList .
  var S : Sort .
  var ECnD : EqCondition .
  var CnD : Condition .
  var HL : HookList .
  var Q Q' : Qid .
  var QL : QidList .
  var QS : QidSet .
  var C : Constant .
  var V : Variable .
  var TQ : TermQid .
  var N N' : Nat .
  var NL : NatList .
  var NNL : NeNatList .
  var QPS : QidPairSet .

  op unsortify : Module -> Module [memo] .
  op unsortify : Module OpDeclSet -> OpDeclSet .
  op unsortify : Module EquationSet -> EquationSet .
  op unsortify : Module RuleSet -> RuleSet .
  op unsortify : Module Condition -> Condition .
  op unsortify : Module TermList -> TermList .
  op unsortify : Module AttrSet -> AttrSet .
  op unsortify : Module HookList -> HookList .
  op unsortify : Module QidSet -> QidSet .
  op unsortify : Module TermQid -> TermQid .
  op unsortify : Type -> Type .
  op unsortify : TypeList -> TypeList .
  op unsortify : Module TermPairSet -> TermPairSet [memo] .

  --- inverse transform intermediate data struct
  op unsortify-1 : Module -> QidPairSet .
  op unsortify-1 : Module OpDeclSet QidPairSet -> QidPairSet .
  op unsortify-1 : Module QidSet -> QidPairSet .

  eq unsortify(M) =
    setRls(
      setEqs(
        setOps(
	  setSubsorts(
            setSorts(M,'U),
	    none),
          unsortify(M,getOps(M))),
        unsortify(M,getEqs(M))),
      unsortify(M,getRls(M))) .

  eq unsortify(M,op Q : TYL -> TY [poly(NNL) AS]. ODS) =
    (op if TYL =/= nil then Q else join(Q k2s-map#(M,TY)) fi : unsortify(TYL) -> 'U [unsortify(M,AS)].)
    unsortify(M,ODS) .
  eq unsortify(M,op Q : TYL -> TY [AS]. ODS) =
    (op if TYL =/= nil then Q else join(Q k2s-map#(M,TY)) fi : unsortify(TYL) -> 'U [unsortify(M,AS)].)
    unsortify(M,ODS) [owise] .
  eq unsortify(M,(none).OpDeclSet) = none .

  eq unsortify(M,eq T = T' [AS]. EQS) =
    (eq unsortify(M,T) = unsortify(M,T') [AS] .)
    unsortify(M,EQS) .
  eq unsortify(M,ceq T = T' if ECnD [AS]. EQS) =
    (ceq unsortify(M,T) = unsortify(M,T') if unsortify(M,ECnD) [AS] .)
    unsortify(M,EQS) .
  eq unsortify(M,(none).EquationSet) = none .

  eq unsortify(M,rl T => T' [AS]. RLS) =
    (rl unsortify(M,T) => unsortify(M,T') [AS] .)
    unsortify(M,RLS) .
  eq unsortify(M,crl T => T' if CnD [AS]. RLS) =
    (crl unsortify(M,T) => unsortify(M,T') if unsortify(M,CnD) [AS] .)
    unsortify(M,RLS) .
  eq unsortify(M,(none).RuleSet) = none .

  eq unsortify(M,T = T' /\ CnD) =
    unsortify(M,T) = unsortify(M,T') /\
    unsortify(M,CnD) .
  eq unsortify(M,T := T' /\ CnD) =
    unsortify(M,T) := unsortify(M,T') /\
    unsortify(M,CnD) .
  eq unsortify(M,T : S /\ CnD) =
    unsortify(M,T) : 'U  /\
    unsortify(M,CnD) .
  eq unsortify(M,T => T' /\ CnD) =
    unsortify(M,T) => unsortify(M,T') /\
    unsortify(M,CnD) .
  eq unsortify(M,(nil).EqCondition) = nil .

  eq unsortify(M,C)      = join(getName(C) k2s-map#(M,getType(C)) '.U) .
  eq unsortify(M,V)      = join(getName(V) k2s-map#(M,getType(V)) ':U) .
  eq unsortify(M,Q[NTL]) = Q[unsortify(M,NTL)] .
  eq unsortify(M,(T,TL)) = unsortify(M,T),unsortify(M,TL) .
  eq unsortify(M,empty)  = empty .

  eq unsortify(M,id(T) AS)       = id(unsortify(M,T)) unsortify(M,AS) .
  eq unsortify(M,left-id(T) AS)  = left-id(unsortify(M,T)) unsortify(M,AS) .
  eq unsortify(M,right-id(T) AS) = right-id(unsortify(M,T)) unsortify(M,AS) .
  eq unsortify(M,special(HL) AS) = special(unsortify(M,HL)) unsortify(M,AS) .
  eq unsortify(M,ctor AS)        = AS . --- needed so that Maude doesn't complain about ctor decls
  eq unsortify(M,AS)             = AS [owise] .

  eq unsortify(M,term-hook(Q,T) HL) =
    term-hook(Q,unsortify(M,T))
    unsortify(M,HL) .
  eq unsortify(M,op-hook(Q,Q',TYL,TY) HL) =
    op-hook(Q,Q',unsortify(TYL),'U)
    unsortify(M,HL) .
  eq unsortify(M,id-hook(Q,QL) HL) =
    id-hook(Q,QL)
    unsortify(M,HL) .
  eq unsortify(M,(nil).HookList) = nil .

  eq unsortify(M,TQ ; QS) = unsortify(M,TQ) ; unsortify(M,QS) .
  eq unsortify(M,(none).QidSet) = (none).QidSet .

  eq unsortify(TY TYL) = 'U unsortify(TYL) .
  eq unsortify((nil).TypeList) = nil .

  eq unsortify-1(M) = unsortify-1(M,getOps(M),none) .
  eq unsortify-1(M,op Q : TYL -> TY [AS]. ODS,QPS) =
    unsortify-1(M,ODS,QPS |
      if TYL =/= nil
        then none
	else qp(join(Q k2s-map#(M,TY) '.U),join(Q '. TY))
      fi) .
  eq unsortify-1(M,(none).OpDeclSet,QPS) = QPS .

  eq unsortify-1(M,C ; QS) = qp(unsortify(M,C),C) | unsortify-1(M,QS) .
  eq unsortify-1(M,V ; QS) = qp(unsortify(M,V),V) | unsortify-1(M,QS) .
  eq unsortify-1(M,none)   = none .

  eq unsortify(M,(T : T') | TPS) = (unsortify(M,T) : unsortify(M,T')) | unsortify(M,TPS) .
  eq unsortify(M,.TermPairSet) = .TermPairSet .
endfm

--- This module provides the limited match function which checks that
--- two terms are identical upto a set of allowed patterns
fmod LIMITED-MATCH is
  pr TERMPAIRSET .

  var Q Q' : Qid .
  var NTL NTL' : NeTermList .
  var TL TL' : TermList .
  var T T' : Term .
  var M : Module .
  var TPS : TermPairSet .

  op top : Term -> [Qid] .
  eq top(Q[NTL]) = Q .

  op children : Term -> [TermList] .
  eq children(Q[NTL]) = NTL .

  op limited-match : Module TermList TermList TermPairSet -> Bool .
  eq limited-match(M,(T,TL),(T',TL'),TPS) =
       (T == T' or-else
        (T : T') <|(M) TPS or-else
        (top(T) == top(T') and-then limited-match(M,children(T),children(T'),TPS)))
     and-then limited-match(M,TL,TL',TPS) .
  eq limited-match(M,empty,empty,TPS) = true .
  eq limited-match(M,empty,NTL,TPS) = false .
  eq limited-match(M,NTL,empty,TPS) = false .
endfm
