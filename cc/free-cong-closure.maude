--- congruence closure algorithm with free symbols
---
--- The initial state "init" starts with the sorted list of marked rules generated by the equations specified by the user with constant
--- "equations" in module U-EQ. Roughly, being sorted with smaller righthand sides first should ensure an O(n^2) complexity using hash-consing
--- according to Plaisted-and-Sattler-Klein, but this algorithm is more eager than theirs, since rules are fully reduced by
--- previous ones before being added to a set of inter-reduced rules.  The invariant kept by the algorithm is that the rules
--- in the 1st component are always inter-reduced and therefore convergent (locally confluent, since no CPs exist, and
--- terminating by construction).  This means that when no more equations remain in the third component we have reached the
--- desired congruence closure.  The second component is a version of the convergent rules as a set of equations, to avoid
--- recomputing that set for simplification purposes.  Another invariant is that the rules in the 1st component are
--- sorted by ascending index (order of creation). The algorithm has just five equations:
---
--- 1. The first rule simplifies with "ES" the rule "MR" with smallest righthand side in the third component.  This
---    is done with "simpl-mrule(ES,MR)" (defined in file simplify-marked-term-and-rule.maude). If the result is trivial, it is
---    discarded; otherwise: [i] the resulting simplified rule is numbered and added to the set of inter-reduced rules and to the equation set; and
---    [ii] now the set "IMRL" of inter-reduced rules must be simplified by "simpl-mrule(ES,MR)".  This is done by starting a process as a
---    pair, which first component the results "reduce-imrules(simpl-mrule(ES,MR),IMRL)" (defined in file process.maude), and second
---    component the remaining unprocessed rules "MRL".
---
--- 2. The second rule is the case where rule [i] in "IMRL" was irreducible, so the result is discarded and nothing is done.
---
--- 3. The third rule is the case where the simplified  rule [i] in "IMRL" became trivial, so it is removed from IMRL and ES.
---
--- 4. The fourth rule is the case where the simplified  rule [i] in "IMRL" was reducible and non-trivial, so that, besides
---    removing it from IMRL and ES, it must be inserted in the sorted list of unprocessed rules "MRL" for further processing.
---
--- 5. In the fifth rule no unprocessed rules remain, so a congruence closure has been reached.  The equations are returned;
---    for testing purposes the user-specified equations are simplified by the convergent rules (this is of course unnecessary).

fmod FREE-CONG-CLOSURE is
  pr CONG-CLOSURE-SHARED .

  op [_,_,_,_,_,_,_] : Module Bool List{MRule<} List{IMRule} EquationSet Process Nat -> CCState .

  op init-free-cc : Module Bool List{MRule<} -> CCState .

  vars T T' : GroundTerm .  var ES : EquationSet .  var AS : AttrSet .
  vars i j n m k l : Nat .  vars S S' : SetM{Qid} .  var f : Qid .
  var MR : MRule .  var IMR : IMRule .  var ORG MRL : List{MRule<} . var IMRL : List{IMRule} . var RS : Results .
  var U : Module . var B : Bool .

  eq init-free-cc(U,B,ORG) = [U,B,ORG,nil,none,process-rules(ORG),1] .

  eq [U,B,ORG,IMRL,ES,MR MRL,j] =
       if sm(U,B,ES,MR) == mt-mrule
       then [U,B,ORG,IMRL,ES,MRL,j]
       else [U,B,ORG,IMRL ([j] sm(U,B,ES,MR)),(eq left(sm(U,B,ES,MR)) = right(sm(U,B,ES,MR)) [meta(j)] .) ES,ri(U,B,sm(U,B,ES,MR),IMRL) # MRL,s(j)]
       fi .

  eq [U,B,ORG,IMRL,ES,{i} RS # MRL,j] = [U,B,ORG,IMRL,ES, RS # MRL,j] .

  eq [U,B,ORG,IMRL,ES,{f,[i] mt-mrule} RS # MRL,j] = [U,B,ORG,remove(i,IMRL),rem-att(i,ES), RS # MRL,j] .

  eq [U,B,ORG,IMRL,ES,{f,[i] T [n,S] => T' [m,S']} RS # MRL,j] =
       [U,B,ORG,remove(i,IMRL),rem-att(i,ES), RS # ins(T [n,S] => T' [m,S'],MRL),j] .

  eq [U,B,ORG,IMRL,ES,nil,j] = [ES,0,rewWithEqs(U,ES,ORG)] .
endfm
