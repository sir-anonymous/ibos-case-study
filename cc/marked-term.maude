--- A (meta-)term T is marked with a pair [n,S] where n is its size and S its set of
--- function symbols.  The marking is generated by the function size&ops.  This is done for
--- two reasons: (i) we need the size to order ground terms in an efficient manner (AC-RPO can
--- be expensive and is only used when the size of both terms is the same); and (ii) this
--- will help efficiency by FAILING FASTER when a term must be reduced by a rule, since if
--- both the term and the rule (see marked-rule.maude) are marked, failure can be detected cheaply.
--- Since sets of function symbols should be smalish even when terms are large, set containments
--- are memoized (see set-memo.maude) to fail even faster.

fmod MARKED-TERM is
  protecting META-TERM .
  protecting SETM-QID .
  protecting NAT .

  sorts SMarking Marking MTerm MTerm? .
  subsort MTerm < MTerm? .
  subsort SMarking < Marking .

  op failure : ->  MTerm? [ctor] .
  op [_,_] : Nat SetM{Qid} -> Marking [ctor] .
  op [_,_] : Nat Qid -> SMarking [ctor] .
  op _ _ : GroundTerm Marking -> MTerm [ctor] .

  var C : Constant .   var F : Qid .
  vars T T' = GroundTerm .  vars TL TL' : GroundTermList .
  vars n m : Nat .  vars S S' : SetM{Qid} .

  op p1 : MTerm -> GroundTerm .

  eq p1(T [n,S]) = T .

  op top : GroundTerm -> Qid .

  eq top(C) = C .
  eq top(F[TL]) = F .

  op size : Marking -> Nat .

  eq size([n,S]) = n .

  op _+_ : Marking Marking -> Marking .

  eq [n,S] + [m,S'] = [n + m,S & S'] .

  op size&ops : GroundTermList -> Marking [memo] .  --- memo avoids recomputing for already seen terms

  eq size&ops(empty) = [0,mt] .
  eq size&ops((C,TL)) = [1,C] + size&ops(TL) .
  eq size&ops(((F[TL]),TL')) = [1,F] + size&ops((TL,TL')) .

  op mark : GroundTerm -> MTerm .

  eq mark(T) = T size&ops(T) .
endfm
