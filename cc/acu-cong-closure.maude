--- The initial state "init" starts with the sorted list of marked rules generated by the equations specified by the user with constant
--- "equations" in module U-EQ.  Furthermore, to allow the case where there can be A\/C\U axioms, the second component
--- of the initial state has initially a module with the identity axioms (U) specified as rules.
--- In the case where all symbols are free, roughly, being sorted with smaller righthand sides first
--- should ensure an O(n^2) complexity using hash-consing
--- according to Plaisted-and-Sattler-Klein, but this algorithm is more eager than theirs, since rules are fully reduced by
--- previous ones before being added to a set of inter-reduced rules.  The invariant kept by the algorithm is that the rules
--- in the 1st and 2nd components are always inter-reduced; therefore in the free+U case they are convergent (locally confluent, since no CPs exist, and
--- terminating by construction).  This means that when no more equations remain in the third component we have reached the
--- desired congruence closure.  The third component is a version of the rules in the first component as a set of equations, to avoid
--- recomputing that set for simplification purposes.  Another invariant is that the rules in the 1st component are
--- sorted by ascending index (order of creation). The algorithm has just six inference rules, specified as equations:
---
--- 1. The first rule simplifies the rule "MR" with smallest righthand side in the third component with ES UNION the CURRENT identity rules ES'
---    [since ES' rules can be simplified by generated rules of the form e => e' with e an identity element].  By giving to all identity elements
---    the SMALLEST order among all operators, we ensure that e' will also be an identity element. This simplification of MR
---    is done with "simpl-mrule(U,ES ES',MR)" (defined in file simplify-marked-term-and-rule.maude). If the result is trivial, it is
---    discarded; otherwise:
---
---    [i] the resulting simplified rule is numbered and added to:
---       a .the set of inter-reduced rules
---       b. if its lefthand side is an identity element, so the rule is e => e', then we must simplify with e => e' the lefthand sides
---          of ES' in the second component (with function left-simplified defined in file example-id.maude);
---       c. we must also add it to the equation set;
---       d.  If the top symbol is A or AC, we must also add it to the fourth component (IMRuleTable) that keeps also a table for A or AC rules; and
---
---    [ii] now the set "IMRL" of inter-reduced rules must be simplified by "simpl-mrule(U,ES ES',MR)".  This is done by starting a process as a
---    pair, which first component the results "reduce-imrules(U,simpl-mrule(U,ES ES',MR),IMRL)" (defined in file process.maude), and second
---    component the remaining unprocessed rules "MRL".
---
--- 2. The second rule is the case where rule [i] in "IMRL" was irreducible, so the result is discarded and nothing is done.
---
--- 3. The third rule is the case where the simplified rule [i] in "IMRL" became trivial, so it is removed from IMRL, ES and IMRT.
---
--- 4. The fourth rule is the case where the simplified rule [i] in "IMRL" was reducible and non-trivial, so that, besides
---    removing it from IMRL, ES and IMRT, it must be inserted in the sorted list of unprocessed rules "MRL" for further processing.
---
--- 5. In the fifth rule no unprocessed rules remain, and if m0 = j, a congruence closure has been reached. Then equations are returned;
---    for testing purposes the user-specified equations are simplified by the convergent rules (this is of course unnecessary).
---    Otherwise (m0 =/= j), there may still be rules whose critical pairs have not been computed.  To do so, a process is
---    started creating an "overlap list" with all the remaining index pairs for such critical pairs to be computed later.
---
--- 6. Such critical pairs are created one rule at a time by rule 6, overlapping each A or AC rule with itself and those with same
---    top symbol and having lower or equal index to the given rule.

fmod A\/C\/U-CONG-CLOSURE is
  pr CONG-CLOSURE-SHARED .
  pr QIDTUPLESET .

  op [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_] : Module Module QidPairSet Substitution Bool List{MRule<} List{IMRule} EquationSet EquationSet SetM{Qid} IMRuleTable FAxiomSet List{OInfo<} Process Nat Nat Nat -> CCState .

  vars T T' : GroundTerm .  var ES ES' : EquationSet .  var AS : AttrSet . var FAS : FAxiomSet . var OL : List{OInfo<} .
  var OI : OInfo . vars i j n m k l m0 : Nat .  vars S S' ID : SetM{Qid} . var f : Qid . var ID' : QidSet . var IMRT : IMRuleTable .
  var MR : MRule .  var IMR : IMRule .  var ORG MRL : List{MRule<} . var IMRL : List{IMRule} . var RS : Results . var U CU : FModule .
  var SUB : Substitution .

  var H : Header . var IL : ImportList .
  var B : Bool . var QPS : QidPairSet .

  op init-acu-cc : FModule FModule QidPairSet Substitution Bool EquationSet QidSet List{MRule<} -> CCState .
  eq init-acu-cc(U,CU,QPS,SUB,B,ES',ID',MRL) = [U,CU,QPS,SUB,B,MRL,nil,ES',none,toSetM(ID'),init-imrtab(U),init-faxset(U),nil,process-rules(MRL),0,0,1] .

  eq [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OL,MR MRL,m0,k,j] =
       if sm(U,CU,QPS,SUB,B,ES ES',MR) == mt-mrule
          then [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OL,MRL,m0,k,j]
          else if ax top(left(sm(U,CU,QPS,SUB,B,ES ES',MR))) in FAS == free
                 then if top(left(sm(U,CU,QPS,SUB,B,ES ES',MR))) =< ID == true
                         then [U,CU,QPS,SUB,B,ORG,IMRL ([j] sm(U,CU,QPS,SUB,B,ES ES',MR)),
                                left-simplify(U,eq left(sm(U,CU,QPS,SUB,B,ES ES',MR)) = right(sm(U,CU,QPS,SUB,B,ES ES',MR)) [meta(none)] .,ES'),
                                (eq left(sm(U,CU,QPS,SUB,B,ES ES',MR)) = right(sm(U,CU,QPS,SUB,B,ES ES',MR)) [meta(j)] .) ES,ID,
                                IMRT,FAS,OL,ri(U,CU,QPS,SUB,B,sm(U,CU,QPS,SUB,B,ES ES',MR),IMRL) # MRL,m0,k,s(j)]
                         else [U,CU,QPS,SUB,B,ORG,IMRL ([j] sm(U,CU,QPS,SUB,B,ES ES',MR)),ES',
                                (eq left(sm(U,CU,QPS,SUB,B,ES ES',MR)) = right(sm(U,CU,QPS,SUB,B,ES ES',MR)) [meta(j)] .) ES,ID,
                                IMRT,FAS,OL,ri(U,CU,QPS,SUB,B,sm(U,CU,QPS,SUB,B,ES ES',MR),IMRL) # MRL,m0,k,s(j)]
                      fi
                 else [U,CU,QPS,SUB,B,ORG,IMRL ([j] sm(U,CU,QPS,SUB,B,ES ES',MR)),ES',
                        (eq left(sm(U,CU,QPS,SUB,B,ES ES',MR)) = right(sm(U,CU,QPS,SUB,B,ES ES',MR)) [meta(j)] .) ES,ID,
                        add-imrule(top(left(sm(U,CU,QPS,SUB,B,ES ES',MR))),([j] sm(U,CU,QPS,SUB,B,ES ES',MR)),IMRT),
                        FAS,OL,ri(U,CU,QPS,SUB,B,sm(U,CU,QPS,SUB,B,ES ES',MR),IMRL) # MRL,m0,k,s(j)]
               fi
       fi .

  eq [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OL,{i} RS # MRL,m0,k,j] =
       [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OL,RS # MRL,m0,k,j] .

  eq [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OL,{f,[i] mt-mrule} RS # MRL,m0,k,j] =
       [U,CU,QPS,SUB,B,ORG,remove(i,IMRL),ES',rem-att(i,ES),ID,remove([i,f],IMRT),FAS,OL, RS # MRL,m0,k,j] .

  eq [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OL,{f,[i] T [n,S] => T' [m,S']} RS # MRL,m0,k,j] =
       [U,CU,QPS,SUB,B,ORG,remove(i,IMRL),ES',rem-att(i,ES),ID,remove([i,f],IMRT),FAS,OL,RS # ins(T [n,S] => T' [m,S'],MRL),m0,k,j] .

  eq [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,nil,nil,m0,k,s(j)] =
       if m0 == j
          then [ES ES',k,rewWithEqs(U,ES ES',ORG)]
          else [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,compute-overlaps(IMRT,m0),nil,j,s(k),s(j)]
       fi .

  eq [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OI OL,nil,m0,k,j] =
       [U,CU,QPS,SUB,B,ORG,IMRL,ES',ES,ID,IMRT,FAS,OL,clean(sort(make-rule-map(U,CU,QPS,SUB,B,CPS(U,OI,IMRT,FAS)))),m0,k,j] .
endfm
